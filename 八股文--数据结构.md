### 红黑树

1. 五大性质：

   - 黑根+黑叶+黑路+红黑色+红离散=避免退化成单链表

   - 衍生性质：最短路径是全黑，最长红黑相间，呈现两倍关系

2. 红黑操作：

   - 四种插入，看父节点：

     > 1.根节点；
     >
     > 2.父黑；
     >
     > 3.父叔双红：父叔涂黑，爷红；递归爷；
     >
     > 4.父红叔黑：
     >
     > ​	父N同左=换色+爷右旋；
     >
     > ​	父N同右=换色+爷左旋；
     >
     > ​	父左N右=父左旋+递归；
     >
     > ​	父右N左=父右旋+递归；

   - 三种删除

     > 1.删除叶子结点
     >
     > ​	删除红色叶子结点=直接删
     >
     > ​	删除黑色叶子结点 :apple:需要修复
     >
     > 2.删除只有一个儿子的节点：swap儿子=叶子
     >
     > ​	自身是红色=直接删；
     >
     > ​	自身是黑色=情况1.2；
     >
     > 3.删除有两个儿子的子结点：swap后继=后继
     >
     > ​	后继是叶子=情况1
     >
     > ​	后继只有一个儿子=情况2；
     >
     > 综上只需要研究:apple:`删除黑色叶子结点`即可。

     > :apple:删除黑色叶子结点：
     >
     > 1. 兄弟黑色且有一个儿子：三分天下（先捋直）
     > 2. 兄弟黑色且有两个儿子：先捋直，再分配颜色旋转
     > 3. 兄弟黑色且没有儿子：兄弟变红，递归父亲
     > 4. 兄弟红色且必有两个儿子：先捋直，再分配颜色旋转































































1. 二叉搜索树BST AVL 红黑树 B树

   平衡二叉搜索树AVL，234树，一个2-3-4树对应多个红黑树；（由来和意义？）2-3-4树是一个满树，有多少个子结点就叫这个节点是几节点。

2. 一个红黑树只能对应一个234树，但是一个234树可以对应多个红黑树。

3. 第四个结点要进来时，原来的四结点中间的节点会**上弹**。

4. 红黑树中2 -3-4节点都是上面黑，下面红。红黑树新增都是以红色的身份插入进来。在裂变状态的前一个状态时，被插入位置是一个4节点，此时中间节点是黑色的，而一旦插入了另外一个，那么它会变成红的上弹出去，而其他两个会是黑色的。如果上弹的元素变成了根节点，那么还是会变黑。

5. 子结点在左边就是左倾，子节点在右边就是右倾。红黑树上任何一个黑色节点的数目都是相同的。

6. **红黑树五大性质**

   >   节点带色+根是黑色+叶子黑色+红色必有两个黑子+黑色平衡

7. 空节点是黑色的。2-3-4树每个节点都会有一个黑色的。

8. 二叉树中如果要删除节点，要找到前驱和后继节点。这与找最值是分不开的。最后不要真的以为是删除某个节点，可以把它统一到替换值上面来。

9. **寻找前驱节点**：如果存在左子树，那么必定在左子树的右枝；如果不存在左子树，那么其前驱节点必定在尖顶的左父亲（第一个左拐的地方）。

10. 红黑树节点的删除：







**2.优先队列**

使用的时候语法要求：

priority_queue<int,vector<int>,less<int>()>；默认是less<int>()

对于sort，同样默认是less<int>();

优先队列其实就是一个堆，堆就是一个完全二叉树，能同时保证父子结点的顺序关系。

**3.二叉树**

a.二叉搜索树是个有序树，平衡二叉搜索树AVL。

b.C++中map set multimap multiset 的底层实现都是平衡二叉搜索树，

c.unordered_set unordered_map 底层实现是哈希表。

d.二叉树可以用链式或者数组两种方式储存。

e.二叉树主要有两种遍历方式，分别是深度优先搜索dfs和广度优先搜索bfs

前者分为前中后序遍历，后者就是层序遍历。

dfs是可以借助栈来实现非递归的实现方式的，而bfs要借助队列。

g.骚操作：auto [v, l, r, n] = *Node;

【117】比较高级

【110】这题能够用作二叉树递归过程中碰到异常值如何处理的例子。

【513】的dfs实现？

【113】传值与传引用的不同。传引用居然可以实现

[二叉树层次遍历的dfs实现]

```
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        dfs(res, root, 0);
        return res;
    }
    void dfs(vector<vector<int>>& res, TreeNode* root, int level) {
        if (!root) return;
        if (level >= res.size())
            res.push_back(vector<int>());
        res[level].push_back(root->val);
        dfs(res, root->left, level + 1);
        dfs(res, root->right, level + 1);
    }
};
```

【公众号】https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/面向大象编程

https://blog.csdn.net/fuxuemingzhu/article/details/101900729



### 红黑树

1. 二叉搜索树BST AVL 红黑树 B树

   平衡二叉搜索树AVL，234树，一个2-3-4树对应多个红黑树；（由来和意义？）2-3-4树是一个满树，有多少个子结点就叫这个节点是几节点。

2. 一个红黑树只能对应一个234树，但是一个234树可以对应多个红黑树。

3. 第四个结点要进来时，原来的四结点中间的节点会**上弹**。

4. 红黑树中2 -3-4节点都是上面黑，下面红。红黑树新增都是以红色的身份插入进来。在裂变状态的前一个状态时，被插入位置是一个4节点，此时中间节点是黑色的，而一旦插入了另外一个，那么它会变成红的上弹出去，而其他两个会是黑色的。如果上弹的元素变成了根节点，那么还是会变黑。

5. 子结点在左边就是左倾，子节点在右边就是右倾。红黑树上任何一个黑色节点的数目都是相同的。

6. **红黑树五大性质**

   >   节点带色+根是黑色+叶子黑色+红色必有两个黑子+黑色平衡

7. 空节点是黑色的。2-3-4树每个节点都会有一个黑色的。

8. 二叉树中如果要删除节点，要找到前驱和后继节点。这与找最值是分不开的。最后不要真的以为是删除某个节点，可以把它统一到替换值上面来。

9. **寻找前驱节点**：如果存在左子树，那么必定在左子树的右枝；如果不存在左子树，那么其前驱节点必定在尖顶的左父亲（第一个左拐的地方）。

10. 红黑树节点的删除：



### vector攻略

1.不同的编译器vector有不同的扩容大小，VS=1.5倍；GCC=2倍。2倍的时候有个问题就是不能复用前面已经用过的空间。

2.vector的capacity在使用后无法变化，如果要释放这块内存可以借助临时对象：

`vector<int>().swap(myUsedVectorName)`

3.std::erase()，以及vec.erase(iter);



### map攻略

1.unordered_map中的底层构造是哈希表。

2.map的插入方式：

> ```C++
> table.insert({1,2});
> table[6] = 7;
> table.insert(std::pair<int ,int>(2,3));
> table.insert(make_pair(4,5));
> table.insert(map<int ,int>::value_type(8,9));	
> ```

3.如果用一个map中不存在的key进行查找，会默认插入0；

### unordered_map/unordered_set攻略

1.扩容时间：当哈希表中已经容纳的元素个数=哈希表桶的个数*负载因子

### list攻略

1.splice(位置-iterator，内容one-list，区间range-iterator);

2.std::advance(iterator,steps);





