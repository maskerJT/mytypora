### 刷题总结

1. 数组中找n个数，其和为target的解法：对数组排序后，深入至最内两层，找left和right两个指针。
2. 字符串的填充问题，可以预先扩容再从后往前赋值，不用额外空间。151题。
3. KMP算法28题和549题。
4. 单调队列题目：在数组中滑动大小为k的窗口，返回窗口中的最大值：维护一个长度为k的单调队列，
5. 贪心算法没有固定模板：感觉局部最优可以推出最优解并且找不到反例，那就是贪心。
6. s.substr(1,s.size());
7. 摩尔投票法：找到数组中出现超过半数的数字。
8. 异或运算的各种性质：相反数相与&得到最低位的1形成的数量。
9. 快速幂
10. 字符串的比较 lambda x+y<y+x
11. 深刻理解三种dfs的逻辑中每一层递归的内涵。
12. 丑数的动态规划
13. 子字符串：s.substr(index,num);

### 动态规划

1. 背包顺序问题
   - 01背包中，二维数组背包和物品的顺序无关，一维中必须先遍历物品，内层倒序。
   - 完全背包中，与遍历顺序无关，都是顺序。
   
2. 最基本的背包是：给定容量，求其最多能装多少货物；

   还有另外一种是：给定容量，求填满它的方法的数量；这是一个组合问题。循环方式不变，改变递推公式。

3. 普通背包求组合数；特殊背包求排列数；

### 回溯

1. 前置步骤不要干预回溯的逻辑，否则将报错。[39题组合总和](https://leetcode-cn.com/problems/combination-sum/submissions/)

2. 回溯法的一道题 [491.递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)这道题在回溯部分破天荒的没有对start到end进行遍历，而是进行判断，如果大于等于前面的数，就再次回溯，这样就避免了在同一层中出现两个同样的数。

3. **求子集问题完全攻破**：组合题目中，碰到要进行去重的时候，使用unordered_set的方式无法成功，因为其底层是哈希表，哈希表可能无法面对这种大小不确定的数据类型。可以使用set来进行去重。另外一种方式是，还是按照自己的朴素迭代方式去重，根据这种思路，在面对nums[i]重复的时候，只需要选择res尾部的部分元素加num[i]即可。

4. 全排列问题：

   > 一个集合的全排列问题，可以看成与子集一样的问题：通过分割nums左边是已经使用的，右边是没有使用的，每递归一次，分割处右移一次；也可以使用一个used数组来indicate其使用情况，如果被使用了就是true，不过此时并不需要使用一个分割位置的int，每次都要从0开始遍历。
   
5. 有重复元素的全排列问题：

   - 还是按照上述全排列的方法，针对于原数据的引用，只需要在dfs的循环中的第一句加上sort即可。因为上一个加入temp的元素时swap进来的。而一旦排好序什么都好说了。（排序可以只在for循环中实现）

   - 针对于原数据的复制，此时进行swap并没有必要再swap回来，由于temp不存在所以也没有所谓的pop_back()操作。要注意的地方是

     **去重**这一步时，要判断每个i与cur的值是否相等，而不再是i与i-1。【严重注意】必须要先在主函数中排序。因为每次swap的时候，都是针对前一时刻的原数据进行操作，比如313一个for操作之后变成了313+133+331，这样继续往下必定会重复。比如313下一层的331跟本层的331重复。

   - vector<bool>used数组记录的方式：for循环要从0开始，要判断是否同一层已经使用过同一个数。
   
6. 欧拉路径：【332】飞机机票回环：

   ```C++
   void dfs(string start) {
           while (table[start].size() != 0) {
               string next = *table[start].begin();
               table[start].erase(table[start].begin());//可能存在相同的地点，所以只能erase迭代器
               dfs(next);
           }
           res.push_back(start);//一定倒着存,将孤立节点放在最后访问。题目保证一定会有路径
       }
   ```

   7.解数独：最后一个一定要使用break或者return跳出循环，不然的话会继续回溯。
   
   

### 输入

1. cin一个字符串时，第一次读取到空格前的部分，如果不想空格后的缓冲区影响第二次cin，可以使用cin.sync()进行清空。
2. cin一些基本数据类型如int，float等，遇到结束符（空格+换行+tab）都会导致输入结束。



### 大小写

1.大写变小写、小写变大写 : 字符 ^= 32;

大写变小写、小写变小写 : 字符 |= 32;

小写变大写、大写变大写 : 字符 &= -33;



### 贪心

跳跃次数=for循环中的当前最大可前往步长；

cmp函数中要使用引用参数。





### 数学定理

1.裴蜀定理：最大公约数是1时，则必定整数线性方程可以等于1；





### 单调栈

1.https://zhuanlan.zhihu.com/p/352430837























# 日常维护题目

- 42-接雨水
- 84-柱状图最大矩形 
- 739-每日温度
- 496-下一个更大的元素

回溯法：

- 39-组合总和
- 40-组合总和2

动态规划：

- 377-组合总和3（完全背包中求排列数）

  > - 完全背包中：
  >
  >   **如果求组合数就是外层for循环遍历物品，内层for遍历背包**。----普通思路（322零钱兑换I、518零钱兑换II）
  >
  >   **如果求排列数就是外层for遍历背包，内层for循环遍历物品**。（377"组合"总数）
  >
  >   `注意在完全背包中二者的遍历顺序，如139-单词拆分，组合或者排序存在就可以了，因此不在意循环次序`
  >
  > - 0-1背包中：
  >
  >   二维数组背包和物品的顺序无关，一维中必须先遍历物品，内层倒序。---普通思路
  
- 打家劫舍

  > - 如果首尾相连，如何保证首尾中只偷一个呢？
  > - 如果是树的话，可以同时记录下来偷与不偷的vector。
  
- 买卖股票

  > - 买卖一次股票
  > - 买卖多次股票
  > - 只允许买卖两次股票（分成多个状态）
  > - 只允许买卖k次股票
  > - 包含冷冻期的买卖股票
  > - 没一次完成买卖的手续费的股票
  
- 子数组与子序列

  > - 最长递增子序列lower_bound二分
  > - 最长重复子数组

- 归并排序：

  > - 计算逆序对315，493

深度优先遍历

- 岛屿类问题

  > - 200岛屿数量
  > - 695岛屿的最大面积
  > - 463岛屿的周长*
  > - 827最大人工岛*







### 图论

1. 拓扑序列，又称有向无环图DAG：directedAcyclicGraph;

   循环停止的条件：不存在入度为0的顶点。

















