1.为什么线程？

- 可以共享同一块地址空间和可用数据+更轻量级更容易创建和撤销+IO密集场景下的加速。

2.有限状态机FSM：有限个状态与状态之间的转移和动作等行为的数学模型。状态机可以分为四个要素：现态+条件=动作+次态；

3.三种事务逻辑的解决方案：单线程+多线程+有限状态机；单线程保留了阻塞系统的简易性，但是放弃了性能；多线程使顺序进程的思想保留了下来，实现了并行性但是会阻塞系统调用；有限状态机运用了非阻塞调用和中断，通过并行实现了高性能但是增加了编程困难。

4.进程用于把资源集中在一起，线程则是CPU上调度执行的实体。线程和进程都具有：运行+阻塞+就绪+终止的状态。每个线程都会有自己的堆栈。

5.POSIX thread=pthreads, 在用户空间实现线程的优势：

- 由于不需要切换到内核，因此不需要上下文切换，不需要对内存高速缓存刷新->启动时比内核调用效率高。
- 每个进程可以有自己定制的调度算法。

在用户空间实现线程的劣势：

- 无法实现阻塞系统调用：系统级的应用比如读取键盘是要经过操作系统的。
- 几种缺页中断算法FIFO+LRU+LFU的实现？

6.进程间竞态条件：两个或者多个线程同时对一个共享数据进行修改，从而影响程序的正确性。可以把共享的资源放入临界区。

7.忙等互斥：

屏蔽中断+锁变量+严格轮询法+Peterson解法+TSL指令

8.严格轮询法：忙等待（死循环检查某个变量的值）浪费CPU时间，一般只有在等待时间非常短的情况下才使用。这种用于忙等待的锁称为spinlock自旋锁。另外还有个大缺陷：如果A退出临界区并且把条件量设为B,此时如果B在非临界区外干别的事，这个时候即使A想再进B也是不可能的了。

9.peterson解法：构造了一个进入与离开临界区函数，主要通过线程识别号和线程转态号来完成。当A进来时，线程号和状态号均对应为A；此时若B进来，即便线程号和状态号都为B，但是主函数体中有一个判别A状态是否为真的条件，因此，B只能在这个死循环中等待，直到A出来，并把自己的状态设为false。

10.TSL/XCHG指令：test and set lock, 执行这个指令的CPU会锁住内存总线，从而禁止其他CPU在这个指令结束之前访问它。这个与屏蔽中断不同，屏蔽中断时，别的核还是可以访问这个内存。

11.优先级反转：一个很高优先级的任务在通过信号量机制访问共享资源时，该信号量已经被一个很低的优先级任务占有，因此造成高优先级任务被许多中间的优先级任务阻塞的情况，实时性得不到保证。解决这种问题的方法有优先级天花板和优先级继承两种方法。（还有不可抢占和禁止中断的方法。）不可抢占背离了优先级设计的初衷，而禁止中断跟不可抢占差不多，只是粒度没有不可抢占那么极端。

12.优先级继承：当高优先级任务发现资源被低优先级的任务占据时，暂时将这个低优先级的任务提升到与自己一样高的优先级，从而防止被中等优先级的任务截胡。但是这个方法仍然存在问题：（a）把低优先级的任务提升上来的时候，如果这个提上来的任务继续请求一个正好被高优先级任务占有的资源，就会出现互相等待的情况，形成死锁。(b)高优先级的任务被迫为很多其他的低优先级提升优先级从而被阻塞的情况称为链阻塞。

13.优先级天花板：当任意一个任务获取到临界资源时，将其优先级提升到优先级天花板，从而不会被其他人抢占。

14.生产者消费者问题:

- 如果只使用一个指示缓冲区的变量来协调两个线程，会产生互相阻塞：`唤醒尚未进行睡眠状态的进程会导致唤醒丢失`，一个解决办法是增加一个`唤醒等待位` ：当`wakeup`状态因为另外一个线程还没有睡眠的时候而即将丢失的时候，将唤醒等待位置1，所以当这个线程准备睡眠时会仍然保持清醒，并且把这个等待位清0。但是如果线程数量有很多的时候，又要增加更多的唤醒位，没有从根本上解决问题。
- 信号量去掉计数能力时的一个简单版本是MUTEX互斥量。
- 为了确保信号量可以正确地工作，最重要的是采用一种不可分割的方式来实现它，通常这些实现方式是作为系统调用来实现的，而且操作系统只需要在执行以下操作的时候暂时屏蔽全部中断：`检查信号量+更新+必要时使进程睡眠`。

15.随着并行的增加，有效的同步和锁定对于性能来说是非常重要的。`在用户态中，如果等待的时间短，那么可以使用自旋锁；而时间长就会浪费CPU周期；在内核态中，如果进程多可以使用阻塞，而如果线程之间竞争并不激烈的时候内核切换的消耗非常大`。为了结合它们之间的优点形成了futex。

16.futex能够实现基本的锁定并避免陷入内核中。它由`内核服务+用户库`组成。理想的同步态应该是在没有锁冲突的情况下用户态利用原子指令就解决问题，而需要等待挂起的时候再使用内核提供的系统调用进行睡眠与唤醒。它是这样工作的：`内核服务提供一个等待队列`允许多个进程在锁上排队。如果没有竞争，可以直接抢占该锁，那么线程直接在用户空间中工作；否则这些线程就会进入等待队列。也就是说：**如果没有锁的竞争，内核就不会参与进来。**

17.Pthread中处理有普通的MUTEX之外，还有第二种同步机制，为**条件变量**，用来提示线程没有满足某些条件而阻塞，或者是在本身在阻塞之后通过它来唤醒自己。通常互斥量和条件变量是一起使用的。条件变量不是计数器，不能像信号量一样可以积累以便后续使用，如果该条件变量上没有等待进程，那么信号会丢失。

18.一个更高级的同步原语：管程(monitor)。它是一个语言概念，它是某些编程语言的特性，C不支持管程。`管程是程序+变量+数据结构等组成的一个集合，任何时候管程中只能有一个活跃的进程`。

19.当一个管程发现不能继续运行比如缓冲区满了时，此时会调用进程阻塞，将另外一个在管程中等待的进程调入管程，这种切换有三种方式：`a新唤醒的进程继续运行然后挂起之前的进程 b之前的必须要退出管程再调用新进程。 c让执行signal的进程继续运行，等待它退出管程时，其他进程才能进入。`

20.除了共享缓存以外，还可以使用消息传递来解决生产者消费者问题。



