### 设计模式

前言：封装继承和多态

封装可以隐藏内部实现，继承可以实现代码复用，多态可以改变对象行为；

###  简洁描述

[23种设计模式](https://zhuanlan.zhihu.com/p/345126462)

### 分类

**创建型模式**：工厂模式+抽象工厂模式+原型模式+构建者模式+单例模式

**结构型模式：**配适器模式+桥接模式+过滤器模式+组合模式+装饰器模式+外观模式+享元模式+代理模式

**行为型模式：**责任链模式+命令模式+解释器模式+迭代器模式+中介者模式+备忘录模式+观察者模式+状态模式+空对象模式+策略模式+模板模式+访问者模式

### 面向对象设计原则（一开隔倒里迪）

> 单一职责原则：只承担一项任务；
>
> 开放关闭原则：类应该对扩展开放，对修改关闭。
>
> 里式替换原则：子类可以替换父类的位置。
>
> 依赖倒置原则：高低层都依赖抽象，细节依赖抽象；*顾客去不同的网店买东西*
>
> 接口隔离原则：避免类中接口污染；类之间接口尽可能小。
>
> 最少知识原则：（迪米特法则）不要跟陌生人谈话。

### UML图

类图中常见的关系：**泛化+实现+关联+聚合+组合+依赖**

实线三角：继承  

虚线三角：实现

虚线尖角：依赖（动物依赖氧气和水）    

实线尖角：关联（丈夫与妻子，老师与学生）

菱形实线尖角：聚合（汽车与轮胎）



### 1.工厂模式（女娲造人）

分为简单工厂模式+工厂方法模式+抽象工厂模式；当创建对象需要一系列复杂的初始化操作比如：关联其他成员对象、查配置文件、查数据库表等，可以设计一个工厂类，专门负责对象的创建工作。

**简单工厂模式：**客户端通过传入参数决定具体子类对象；不过这时如果新加入一种子类类型，那么要新加if-else，不符合对象的开放-封闭原则。

```c++
auto p=new factory;
product = p->produce("A product");
```



**工厂方法模式：**这时就需要为每个子类创建一个工厂子类，让这些工厂实现抽象的工厂接口。

```c++
auto pA=new factoryA;
auto productA=pA->produceA();

auto pB=new factoryB;
auto productB=pB->produceB();
```



**抽象工厂模式**：如果每次新需求一个新子类，都要创建一个工厂，这样太繁琐了。这时可以把产品子类进行分组，**同组中的不同产品由同一个工厂子类的不同方法创建**，从而减少工厂子类数量。（现在一个厂子可以干不同的事，比如生产某类产品的同时，再生产一个对应的赠品。）

```c++
auto p=new factoryA;
auto productA1=p->produceA1();
auto productB1=p->produceB1();
```

### 2.单例模式

定义：在内存中只会创建一次且仅只创建一次的对象，防止频繁创建对象使得内存飙升。

实现形式：将构造函数声明为私有函数，同时在public中声明一个能调用造函数的函数。在类中有一个static public/private变量来判断是否已经存在了实例。

**懒汉式**：直到使用时才实例化对象，存在问题：线程安全+内存泄露；解决范式：加锁+智能指针。在加锁的时候一般使用双检锁：在判断单例对象的存在性时，在上锁前后检查两次。其目的是避免在单例已经存在的时候，还老是去申请锁；不足：增加开销；但是仍然可能由于编译器的执行顺序不同而出现差错。

**最佳懒汉式**：在接口函数中声明一个局部变量，由于“当变量在初始化的过程中，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。”在使用的时候需要声明单例的引用来获取对象。之所以不使用指针是因为客户可能提前删除资源：delete singleton;

```C++
static Singleton& get_instance(){
        static Singleton instance;
        return instance;
    }
```

**饿汉式**：不存在上述问题，只不过需要提前实例化。

### 奇异递归模板模式





### 3.建造者模式（组装各个模块）

定义：将一个复杂对象的构建与表示分离；使得同样的构建过程可以生成不同的表示。当一个基本部件不会变，但是它们的组合经常变化时，可以使用。

优点：封装性+独立易扩展；缺点：产品必须有共同点+变化复杂时可能有多种建造类。

角色：Builder+ConcreteBuilder+Director+Product

流程：director与client沟通，然后将需求划分为各个部件的构造请求builder，builder将各个部件的生产请求委派给具体的建造者concreteBuilder，最终形成具体产品。

如果每个客户买车都要自行设计建造顺序，只会让客户抓狂；Director隔离用户与builder；

### 4.模板方法模式

例子：造不同类型的汽车。

定义：定义一个算法的框架，而将一些步骤延迟到子类多态表达；父类中可以有一个钩子函数使得用户可以通过它来屏蔽一些父类的行为，比如响喇叭。

优点：封装了公共不变部分，行为由父类控制，子类进行实现。

缺点：代码阅读复杂度+单继承。

### 5.代理模式

定义：为其他对象提供代理来控制对这个对象的访问。又称委托模式。本质是控制对象访问。

功能：创建一个代理对象，来代表真实的对象，也就是客户端操作代理，代理操作真正的对象。所以代理对象相当于一个中转，在中转的时候就有很多花招可以玩，比如判断一下权限等等。

代理的分类：虚代理（真正需要的时候才会创建真实的对象）+远程代理（不同的地址空间上代表同一个对象）+copy-on-write（只有在实际对象被真的改变的时候才会去真的拷贝它）+保护代理（根据不同客户的权限提供不同的访问权限）+cache代理（为昂贵的操作提供临时的存储空间，以便多个客户端可以共享这些结果，有点Redis的意思）+防火墙代理（防止被恶意用户访问和操作）+同步代理（多个客户端访问目标对象的时候没有冲突）+智能指引（与保护代理类似）。

### 6.中介者模式

定义：用一个中介对象封装一系列的对象交互，使得对象间耦合松散，并且可以独立地改变他们之间的交互。也叫调停者模式。作用类似机场的调度中心。

组成部分：抽象中介者=定义统一的同事间交流的接口；具体中介者=抽象中介者的派生；同事角色；

**优点**：减少类间的依赖，把原本一对多的依赖变成了一对一的依赖。

**缺点**：中介者会膨胀且逻辑复杂。

### 7.原型模式

定义：使用一个原型实例不断地clone或者copy，然后再修改的模式。非常简单。

场景：不断给不同的客户发邮件；

优点：性能优良（直接拷贝二进制流而非new新的对象）+越过了构造函数

缺点：考虑深拷贝与浅拷贝；

###  8.命令模式

场景：甲方提需求的时候，只需要项目经理Invoker统筹谋划就可以了；

定义：将各种命令或者请求封装成一个对象，乙方只管面向这个对象执行就行了；这种模式比较简单，因为它封装性比较好，把请求方和执行放分开了。

优点：类间解耦；缺点：command子类可能会膨胀得非常大；

一些场景比如GUI开发可以使用这个模式。还可以设计任务回滚。

### 9.责任链模式

场景：古代妇女的三从四德；

定义：将接收请求的对象串成一个链，避免请求者和接受者之间的耦合关系。每个接受者都有自己的处理逻辑（一般是判断发来的请求是不是自己的处理级别），并且指定下一级逻辑的对象。

优点：将请求和处理分开，二者没必要认识。

缺点：链表的性能问题，调试的时候可能逻辑比较复杂。

### 10.装饰模式

场景：熊孩子给老爸看成绩单；

直男方式：继承schoolReport然后重写report函数，加一层糖衣；20层继承就很难维护这么多子类了。

高级方式：定义Decorator类包装一下schoolReport；就增加功能来说，装饰模式比生成子类更加灵活。

定义：动态地给对象添加一些额外的职责；

Decorator中聚合了原始的component，然后再decorator中修饰原有的函数；最后在client中就可以通过一次或者多次使用将原始component传递到某个装饰类中去然后再从中重写component的功能。

优点：装饰类和被装饰类可以独立发展，不会相互耦合。它是继承关系的一种替代方案，不管装饰多少层，返回的对象还是component，实现的还是is-a关系。

缺点：多层的装饰是复杂的，比如在外层发现了错误，结果原因在最里层。

理解：继承是静态地给类增加功能，而装饰模式是动态地增加功能，继承会增加很多子类，子子孙孙的，类会膨胀。

### 11.迭代器模式

定义：提供一种方法访问一个容器对象中的元素，而又不暴露该对象的内部细节。迭代器一般都有begin+next+end;或者说是FIRST+NEXT+isDone；

优点：可以与多种容器类型配合使用，而不必非要for(;;);

### 12.策略模式

场景：赔了夫人又折兵

定义：定义一组算法，将每个算法都封装起来，并且它们之间可以互换。

角色：Context封装+Strategy抽象策略+ConcreteStrategy具体策略

使用：client根据自己的需要，产生它对应的对象，然后放到封装角色中，封装角色再执行封装后的方法就可以了。

优点：一族抽象策略的实现实现对外的"可自由切换"；避免使用多重条件判断；扩展性非常好；

缺点：每个策略都是一个类，复用的可能性比较小，类的数量太多；并且所有的策略类都要向外界暴露。并且需要提前知道要使用哪个策略；其他的策略比如工厂策略+享元策略+代理模式可以克服这个需要提前知道策略类型的缺点。

策略模式可以跟枚举类型放在一起使用，形成策略枚举。

### 13.适配器模式

场景：借聘人员信息

定义：将一个类的接口变换成另外一种接口，使得二者能够一起工作；也叫做变压器模式。配适器的职责就是把源角色转换为目标角色。

配适器模式有两种实现办法，一种是采用继承原有接口类的方式，另一种是采用组合原有接口类的方式。

**优点**：提高了类的复用度；工具性质的构件，删了也不会对逻辑算法产生影响。通过配适器模式可以减少修改代码带来的风险。

### 14.组合模式

定义：将对象组合成树形结构来表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

由于其主要用来处理树形机构，因此在实际中并不那么常用，但是一旦数据满足树形结构，那么就能发挥很大的作用，使得代码变得非常简洁。与其说它是一种设计模式，不如说它是一种对业务场景的数据结构和算法的抽象，业务需求可以通过树上的递归遍历来实现。

### 15.观察者模式

定义：对象间一种一对多的依赖关系，使得一个对象改变状态时，其他的所有对象都可以得通知并且自动更新。

一种基于事件和响应的设计模式，常用于传统的窗体应用程序，以及游戏开发领域。事件的发起者，也就是被观察对象，可以注册新的观察者或者去掉旧的观察者。subject注册着观察者，当事件发生时，会通知列表中的观察者。

优点：subject与observer是抽象耦合，二者非常容易拓展；并且可以建立一套触发机制。

缺点：开发和调试会比较复杂，可维护性比较差，一个观察者卡壳会影响整体的执行效率，一般采用异步的方式。



### 16.门面模式

场景：写信时的现代邮局；

定义：一个子系统的外部与其内部的通信必须通过一个统一的对象进行。简单地说，门面对象是外界访问子系统的唯一通道；

优点：减少系统的相互依赖，提高了灵活性，并且提高了访问的安全性。

缺点：一旦系统投产以后发现门面有问题很难解决。

### 17.备忘录模式

场景：奇异博士come to bargain；

一个类的职责应当是单一的，因此保留和恢复原始状态由另外的一个类来负责。

定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以后就能从此恢复。

### 18.访问者模式

场景：老板或者会计查看账单

定义：封装一些作用在某种数据结构中各元素的操作，可以在不改变数据结构的前提下定义这些操作。

访问者模式把访问动作封装成了一个抽象基类，通过派生就可以生成不同的访问方式，比如老板只关心盈利，会计还要关心纳税等。

通过在对象中保留一个接收visitor的接口，这样只需要在visitor中定义各种个性化的需求就可以实现对于数据提供方的定制化访问了。

优点：分离无关行为，好的拓展性

缺点：破坏封装，对象结构变化困难。

### 19.享元模式

定义：运用共享技术能有效地支持大量细粒度的对象。

内部状态：对象可以共享出来的东西，不会改变；

外部状态：随着环境改变的，不可以共享的状态。

享元工厂：定义一个池容器比如哈希表，如果池子中没有要返回的对象，那么就新建一个对象，然后再把它放到池中。

优点：减少创建的对象，降低内存的占用，增强程序的性能。

缺点：提高了系统复杂性。

### 20.解释器模式

定义：给定一门语言，定义其文法表示，并定义一个解释器，使用解释器来解释语言中的句子。

优点：可扩展性较好，灵活；

缺点：利用场景较少，文法复杂时难以维护；

场景：SQL符号解析、符号处理引擎，某些表达式的解析器等。

### 21.桥梁模式

定义：将抽象和实现进行解耦，使得两者可以独立地变化。

场景：星巴克的杯子大小和糖度；可以把容量理解为抽象部分，口味理解为实现部分。实现部分是在抽象部分的构造函数重传入的。

继承是一种类间的强关联关系，桥梁模式是类间的弱关联关系。

 优点：抽象与实现分离，扩充能力优秀，实现细节对客户透明。

缺点：要求识别出独立变化的维度，由于关联关系建立在抽象层，所以要求开发者一开始就针对抽象层进行设计。

### 22.状态模式

场景：电梯系统的开关动停的四个状态决定了电梯那些操作可以执行，不能运行时门还开着。

定义：当一个对象内在状态改变时允许其改变行为；

它将状态与行为绑定在一起，根据不同的状态确定其行为

优点：将不同的状态引入到独立的对象中使得状态转换变得更加明确，减少了对象间的相互依赖。

缺点是子类会太多。









































