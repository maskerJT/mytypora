### 八股文C++

### 标准库

1.包含标准函数库和面向对象库

#### 智能指针攻略

**1.内存泄露**

​	两种情况：忘记delete+过早delete；

智能指针作为系统的普通变量系统会分配到栈内存上，超出作用域会自动析构。

**2.auto_ptr的问题**

a、将数组赋值给auto_ptr时，原数组中的指针所有权转移，后续无法使用，反直觉；（支持operator=）

b、auto_ptr做形参的时候，导致资源被偷走（支持拷贝构造）

导致很多原始指针的使用场景将不能使用auto_ptr

**3.unique_ptr**

它是资源原始指针的唯一所有者，只能在创建的时候通过传递的方式创建，无法复制（=delete），只能移动。C++14中有make_unique()的函数。

包含的方法有`get、reset、release` 

**4.shared_ptr**

同一个资源可以由多个shared_ptr共同托管，当所有托管者消亡的时候删除资源。shared_ptr中析构函数的默认函数delete无法满足需求时，需要添加自定义删除器。

创建多个shared_ptr的方法应当是用一个已经存在的shared_ptr来传递；更不要用栈中的指针来关联shared_ptr。

引用计数的原理：模板类中有一个成员shared_count，也是一个模板类，内部有一个指向base_impl的指针，而所有引用同一个对象的shared_ptr都会共用这个指针。对于这个共享指针，采用原子操作保证该区域中的引用计数值被互斥地访问。

**5.weak_ptr**

只引用，不计数；避免引用成环或者循环引用的问题。

expired判断是否失效，lock避免被释放。

**6.RAII**

RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。



#### 虚函数攻略

1.定义：一个接口，多种实现。

2.多态分为编译和运行时多态。编译时多态体现在**模板和重载；**运行时多态体现在**虚函数机制**。

3.多态的表现形式：派生类指针可以赋给基类指针，派生类对象可以赋给基类引用。

4.底层实现：虚表指针+虚函数表。

- 根据基类的个数可以分为单继承和多继承模式，后者派生类中会出现多个虚表指针指向各个基类的虚函数表。

5.多继承可能出现的问题：直接基类继承自一样的间接基类，菱形继承带来了二义性和多份拷贝的问题。

6.虚继承只影响了孙子，不会影响派生类本身，但是实际开发当中，很少需要基类中的某个类是虚基类，况且新类的开发者也不应该改变已经存在的类体系。

7.虚基类成员的可见性：如果直接基类没有定义基类中某个变量x,那么在这个派生类中访问x，会被解析为虚基类的成员，此时不存在二义性；如果任意一个直接基类定义了x,会覆盖虚基类，因此也不会有二义性；如果直接基类都覆盖了x，会产生二义性。

8.虚析构函数：

实现多态的基类析构函数如果不是虚析构，那么析构过程中无法调用派生类的析构函数造成内存泄露。（只析构了基类的成员）

9.构造函数不能是虚函数：

- 假如是虚函数，编译期无法确定对象类型以及分配空间，运行时也将无从绑定。
- 假如是虚函数，构造函数将依赖虚函数表，而虚函数表又是在构造函数中初始化的。

10.虚函数优缺点：

优点：提高代码复用和结构规范化；

缺点：类空间更大+private被可被访问+虚表的执行效率。

11.构造函数和析构函数不能调用虚函数（C++中失去动态绑定的特性），在对基类进行构造或者析构的时候，此时子类还未构造或者是已经被销毁了。

12.构造顺序：基类-》类成员对象-》派生类 的构造函数

析构调用 派生类-》成员类对象-》基类的 析构函数。

【注意】多个基类时，按照类派生表的顺序构造（而不是初始化列表顺序）；多个类成员时，按照声明顺序（而不是初始化列表顺序）；

13.父类析构必须是virtual，如果是纯virtual,必须提供实现。

14.构造函数和析构函数不能抛出异常；构造函数可以抛出，但是逻辑要完备；析构函数不能抛出异常的原因：第一是无法完备销毁，第二是C++无法处理两个异常，会terminate。

15.为什么纯虚函数不能实例化：提供通用接口语义的作用，动物是抽象的，老虎是具象。

16.以下几种函数不能是虚函数：

**构造+内联+静态+友元+普通**函数



1.类与类之间的关系：has-A, use A, is A;





15.默认构造函数的生成：默认构造的类成员对象+默认构造的父类+虚函数成员+虚基类；



#### 构造函数攻略

1.默认初始化的类内置成员值是未定义的，如果有任何构造函数，将不会生成默认构造函数；

2.struct和class的唯一区别是默认访问权限。

3.如果类中有成员时const+引用+没有默认构造的类成员，**必须使用列表初始化**。

4.base &operator=(base &obj)与 base operator=(base &obj)，使用void operator=(base &obj)的区别：

使用引用的原因是为了实现连续赋值+减少一次拷贝构造和析构（如果不是返回引用的operator=,赋值之后会返回一个*this，这是一个临时对象，而不是新对象的引用）。同时要注意避免自我赋值造成的灾难。if(this=&obj)return *this;

5.构造函数顺序：虚拟基类-》基类-》类成员-》派生类自己的构造函数；

6.类的只能静态构造和只能动态构造：

> **只能静态分配**：在private中重载new。
>
> **只能动态分配**：在private中定义析构函数(但是必须定义一个额外的函数来实现内存空间的释放)，
>
> 但是这种类型不能继承，于是可以在protected中定义析构函数。
>
> ① 动态建立时：A *p = new A();这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；所以“只能动态分配”方式中不能把构造函数定义为private。

7.空类默认产生六种成员函数：

`默认构造函数，拷贝构造函数，析构函数，赋值运算符，取址运算符，取址运算符 const`

8.构造函数的拓展：

初始化列表声明顺序定义+无构造的类成员+虚表+基类构造函数+虚基类构造函数；

9.析构函数的拓展：

执行本函数体析构+成员类对象析构+vptr重定义+父类析构(声明列表顺序相反)+虚基类析构

`多继承类的析构与构造是相反的`

10.如果在析构函数中调用delete this会导致无限递归堆栈溢出。

#### 继承攻略

1.公有继承中：

> 子类对象可以当做父类对象使用
>
> 子类对象可以赋值给父类对象
>
> 子类对象可以直接初始化父类对象
>
> 父类指针/引用可以指向/引用子类对象

2.保护成员：共有继承时无法访问父类的私有成员，因此为了便于派生类的访问，出现了保护成员。

3.类之间的关系：has-A, use-A, is-A.

4.**用C语言实现C++的继承**：指针强制类型转换：

> struct base{void *func}
>
> struct derived{void *func}
>
> **base* ptr=(base*)&derived;**

5.继承中对象之间转换：

**向上类型转换**是安全的（derived转换为base）

**向下类型转换**需要使用dynamic_cast，因为可能有多层派生类。

6.继承相比组合的区别：

> 继承：
>
> 优点：扩展+多态
>
> 缺点：白盒复用，破坏封装性+耦合度高；
>
> 组合：
>
> 优点：黑盒+封装
>
> 缺点：容易产生过多对象。



#### 模板攻略

1.C++模板的底层实现：在声明时对模板代码本身进行编译+调用的时候对参数进行替换后的代码再次进行编译。

2.类模板没有自动类型推导的机制，因此必须显示指明。

3.模板分为函数模板和类模板。一个普通的类或者一个类模板中也可以有函数模板，此时它被称为成员模板。

4.当普通类中的模板存在成员模板时，T的类型由编译器推断；当类模板中存在成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数在第一行，成员模板的参数在第二行。



#### 进程间通信IPC攻略

1.在共享内存中使用stl标准库：

> a.在堆上构造STL容器，然后把容器复制到共享内存中的方式基本是不可能的。
>
> b.进程把容器放在共享内存的确定地址上，告诉另外一个进程这个确定地址。
>
> c.进程在共享内存上使用b放置一个map,然后在map中保存其他容器的确定地址。

2.volatile关键字用处：

起因：由于访问寄存器要快于RAM，因此编译器会减少存取外部RAM的优化。

> 中断服务程序中可能被修改的变量
>
> 多线程中共享的变量
>
> 存储器映射的硬件寄存器



### 函数指针攻略

1.形式`int (*pfunc)(参数列表)`，其中*pfunc的外括号是必须的。



### 类型转换攻略

1.const_cast只针对指针或者引用的常量性。





### 排序攻略

- 插入排序

  













































