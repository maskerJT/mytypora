## 现代操作系统

### 一、死锁

1. 内涵

   > 1. 规范定义：一些进程集合，所有进程都在等待其他进程才能引发的事件，那么这个集合就是死锁的。
   > 2. 死锁分类：**资源死锁（软硬件）+通信死锁**
   > 3. 死锁条件：**资源状态互斥+资源不可抢占+占有与等待+进程环路等待**
   > 4. 四种策略：忽略+仔细分配+检测恢复+破坏死锁条件。
   > 5. 死锁恢复：利用抢占恢复+杀死进程等。

2. 单个或多个资源的银行家算法

   不太实用：进程无法预知自己所需资源的最大值+进程数目不是固定的+资源可能突然不可用。

3. 预防死锁：破坏四个条件

   > 1.破坏互斥条件，一切都使用假脱机程序，比如使用不请求其他资源的打印机守护程序；
   >
   > 2.破坏不可抢占，比如一个虚拟化的打印机向磁盘输出；
   >
   > 3.破坏占有和等待，在一开始就请求全部资源，比如进程开始时，一次拿完所有的资源；
   >
   > 4.破坏环路等待，对资源进行按序编号，比如要请求另外一个资源，必须先释放已有的资源；

4. 其他与锁相关的问题：

   **两阶段加锁**：一个典型的std::lock, 但是并不能避免死锁的问题。

   **通信死锁**：一般可以通过超时技术解决，但是不是通信在网络中发生的都是通信死锁：缓冲区环；

   **活锁**：一直消耗CPU但是既没有进展也没有死锁(比如忙等)的现象，称为活锁；

   **饥饿**：进程的优先级太低导致一直得不到执行。

### 二、锁攻略

1. 自旋锁：忙等待。

2. 互斥锁：睡眠

3. 读写锁

   - 读优先锁：读线程可以持续加锁，无读才写。
   - 写优先锁：写线程排队时，读锁失败。
   - 公平读写锁：读写入队列。

   上述都是悲观锁，认为多线程同时修改资源的概率比较高，所以访问之前都先要上锁。

4. 乐观锁：全程没有加锁，操作完成后如果发现有其他线程改了这个资源，那么就放弃这次操作。如：在线文档。

   原理：更新时，判断版本号是否一致，如果不一致，更新失败。

### 三、虚拟内存

1. 定义：

   系统内存管理技术，使得应用程序认为自己有一个完整的连续可用的地址空间；实际上内存通常被分割为多个物理内存碎片。

2. 实现方式：

   - 请求分页存储管理
   - 请求分段存储管理
   - 请求段页式存储管理

3. 优点：

   - 避免用户直接访问物理内存，防止一些破坏性的操作。
   - 使得用户程序可以使用比实际物理内存更大的地址空间。

4. 缺点：

   - 额外的内存维护管理虚拟内存。
   - 虚拟地址到物理地址的转换。
   - 页面的换入换出需要磁盘IO。
   - 一页可能只有很少的数据。

5. 缺页中断：

   malloc和mmap等内存分配函数只是建立了进程虚拟地址空间，没有分配对应的物理内存，当进程访问没有建立映射关系的虚拟内存时，处理器会自动出发一个缺页中断，此时操作系统会根据页表的外存地址将其调入内存。

6. 页面置换算法：

   - 最佳置换算法OPT：每次淘汰的都是以后不使用或者最长时间不被访问的页面。（过于理想无法实现）
   - 先进先出置换算法FIFO：最简单，脱离实际，算法性能差。它会导致增加内存块数缺页次数反而增多的情况，称为belady异常。
   - 最近最久未使用算法LRU：选择最近一段时间内最久没有用的页面予以淘汰。
   - 时钟置换算法CLOCK：[博客](https://blog.csdn.net/Gu_fCSDN/article/details/103979067?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-1&spm=1001.2101.3001.4242)
   - 改进的时钟置换算法；



### 四、进程间通信

七大方式：**信号+**

1. **信号**：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

   > - 硬件层面有中断，软件层面有某些系统函数以及一些非法运算操作。
   > - 最常发送信号的系统函数有kill、raise、alarm、setitimer、sigqueue、abort等。

2. **文件**：使用read和write，为了实现同步，还需要借助信号。

3. **管道**：分为命名管道和无名管道

   > - 无名管道：父进程创建管道并在管道中写入数据，子进程读出数据。<unistd.h>中的pipe(int pipefd[2])函数；【必须有亲缘关系】
   > - 命名管道：提供一个路径名与命名管道关联，以FIFO文件形式存储在文件系统中，不必有亲缘关系。<sys/types.h>+<sys/stat.h>.
   > - 二者异同：
   >   - 相同点：open打开指针，都是半双工，都需要使用write/read。
   >   - 不同点：是否需要亲缘关系。

4. **共享内存**：最快的IPC，因为不需要来回复制。

   > - 主要API：mmap+munmap+shmget+shmat+shmdt;

5. **信号量**

   > - 是一个整形的计数器；信号量是停车场，值是空余的车位。
   > - 使用：信号量容易出错，使用mutex+condition_variable可以达到同样的效果，并且更加安全。

6. **消息队列**

   > - 使用场景：异步+削峰+解耦；
   > - 异步：**下单-优惠券-积分-短信-结束**；用户的下单操作完成以后，不用考虑后台做的事。为什么不能用多线程去做：难写并且难以排查。
   > - 削峰：秒杀系统时，把请求放到队列中，等高峰下去服务的压力也就没了。
   > - 缺点：
   >   - 系统复杂性=重复消费+消息丢失+顺序消费
   >   - 数据一致性=分布式事务（下单后边的系统放在一个事务中）。
   >   - 可用性=中间件如果挂了怎么办？
   > - 开源MQ：主从式=ActiveMQ+RabbitMQ，分布式=RocketMQ+Kafka；

   > \#include <sys/types.h> #include <sys/ipc.h> 
   >
   > #include <sys/msg.h>
   >
   > **消息队列函数：msgget+msgctl+msgsnd+msgrcv**

   

   

   作者：乔峰援助
   链接：https://zhuanlan.zhihu.com/p/146106297
   来源：知乎
   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

7. socket







   

   

   

