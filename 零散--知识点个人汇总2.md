## 八股文C++

1. sizeof

   - 对象是数组时返回数组的总字节数。
   - 对象是union时返回最大字节成员的字节数。
   - 2级优先级。
   - strlen()返回char*类型的字符串不加\0的长度。

2. 有数组a[10]，那么a和&a的区别是什么？

   a是单个数组元素概念下的首地址，&a是整个数组概念下的地址。但是数组名并不是真正意义上的指针，没有自增自减特性。

3. 野指针是未初始化的指针 ，悬空指针是内存已经被释放的指针。

4. assign或者erase之后，所有迭代器无条件失效，如果再用之前获得的迭代器是一种未定义行为。可以将迭代器重新定向到下一个元素（可能换了地址）的迭代器这样也勉强能遍历数组。

5. java与C++的区别？

6. C++中struct和class功能几乎一样，但是两者默认的继承关系和成员可见性不同，与此同时struct不支持模板编程。

   C与C++中的struct区别大了去了：C中struct不允许成员函数，只是一个用户自定义数据结构，而C++是一个抽象数据结构。

7. 宏定义的用法：在预处理这一步起作用：文件包含和条件编译之后，进行宏展开，难点在于运算的优先级。有一些特殊功能的宏定义比如连接字符串。

8. 构造函数不能是虚函数，基类中的析构函数可以是纯虚函数。对于构造函数而言：从存储空间角度，虚函数对应于虚表指针，当虚构造函数时查表一看由于尚未构建根本查不到。从使用的角度，【】【】】【】

9. 重载overload父子关系与函数是不是虚函数无关且要求必须有差别，重写override平级关系要求格式完全一样，隐藏hide父子关系表示子类对父类的覆盖，或者不管参数是否一致只要同名都隐藏父类函数。

10. 虚函数表构建在编译阶段，同一个类的所有对象公用一个虚表。虚表保存虚函数入口地址。对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数。

11. 构造函数有六种：默认构造+列表初始化构造+拷贝构造+移动构造+委托构造+转换构造。委托：可以在一个构造函数中调用其他构造函数；转换：跟类构造函数的隐式转换有关，当只有一个参数时的情况下可能会发生。

12. 内联函数

    类中的函数默认都是inline的，内联函数是一种空间换时间的方式，编译器会将内联函数的代码与调用出的代码进行替换，而一般的函数在调用时会跳转。

13. decltype

    ```c++
    Widget w;
    const Widget& temp = w;
    auto a = temp; // a's type is Widget
    //下面用来完美推导变量的类型： 
    decltype(auto) b = temp; // b's type is const Widget&
    ```

14. 计算机的大小端：

    大端：扭曲；

    小端：正常；现在一般都是小端的计算机，除了一些路由器。

15. mutable与volatile：

    前者是为了突破const的限制，表示值可变，后者是为了防止被编译器优化掉，防止优化编译器的时候从内存装入到CPU寄存器中，表示每次取值都要从内存中读取而不是读取寄存器中的备份。

16. C++中的new：

    plain new, 分配失败时抛出异常，std::bad_allloc;

    nothrow new, 分配失败时返回null；

    replacement new, 在已经分配成功的内存上重新构造对象或者对象数组，做的唯一一件事情就是调用对象的构造函数，根本不分配内存，因此不会分配失败。不过要注意使用时要显示地调用其析构函数。

17. C++模板如何实现：

    编译器不会把函数模板处理成能够处理任何类的函数，而是会对函数模板进行两次编译，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。

18. delete如何知道被释放内存的大小？ 

    new[]一个对象数组时，会多分配四个字节大小的空间专门保存数组的大小，删除时就读取出这个数。

19. trival的存在能够对内存的拷贝分配等更高效的完成，提升效率。

20. 静态成员函数与一般成员函数的唯一区别是没有this指针。this指针是类的指针，指向对象的首地址；但它不是对象的本身，不会影响sizeof;this 指针在对象构造前存在，在执行结束后清除；this指针因编译器的不同有不同的放置位置：栈、寄存器、全局变量等。

21. C++中不提倡在构造和虚构函数中调用虚函数，如果调用则使用当前类中的版本。父类对象会在子类之前构造因此调用子类的虚函数是不安全的；此外在使用析构函数销毁一个对象时，先调用子类的析构函数，再调用父类的析构函数，也就是说在调用基类的析构函数时，子类的数据成员已经销毁，再调用子类的虚函数没有任何意义。

    构造函数非虚：如果对象没有实例化就找不到虚函数表，因此构造函数不能virtual+构造函数是创建对象时自动调用的，不存在使用基类指针调用的情况，因此不用虚函数。

22. 构造函数调用顺序：

    基类构造函数+成员类对象的构造函数+派生类构造函数。

23. 析构函数顺序：

    派生类析构函数+成员类对象的析构函数+基类析构函数。

24. 虚析构函数的意义：

    当使用一个基类指针调用派生类对象的析构函数时，使得该函数能够动态绑定到派生类的析构函数，从而避免内存泄露。

    如果有纯虚析构函数也要定义，因为缺乏任何一个基类析构的定义都会导致链接失败。

25. Ctors/Dtors可否抛出异常？

    Ctors中抛出异常，Dtors不会被调用，会造成内存泄露。解决办法是在构造中使用智能指针。

    Dtors中抛出异常，且没有当地捕捉，会导致析构函数执行不全。

26. C++强制类型转换：

    `reinterpret_cast/const_cast/static_cast/dynamic_cast`使用方法。

27. C++函数调用的压栈过程：

    （主）函数的返回地址+函数从右到左的参数+函数定义的变量依次压栈；然后将栈中的变量依次弹出，最后主函数返回。

28. 移动构造函数：

    设计背景+设计原理。
    
29. 右值：

    分为纯右值（临时变量与字面值量）；将亡值（std::move，T&&类型的返回值）；

