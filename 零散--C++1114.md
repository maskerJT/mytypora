## C++11/14

#### 一、语言，语法，关键字

1. type_traits/unordered_set/forward_list/array/tuple/regex/thread头文件。

2. variadic templates: 帮助模板做递归：

   > template<typename ...Types>
   >
   > void print(types& ...args){...}

3. sizeof...(args)来获得参数的个数。

4. 1+n和n的参数写法可以并存。

5. tuple的定义是通过variadiic templates来完成的。

6. nullptr是一个新的关键字，可以用来设置0或者0指针。

7. 一致性初始化：uniform initialization，可以在变量名字后边直接加大括号，之前的方式有很多，比如：

   > class object={1,2,3};
   >
   > class object(1,2,3);
   >
   > 现在直接class object{1,2,3}

8. 编译器一看到{}就会做出一个Initializer_list，这个东西会关联到一个array，可以被编译器分解逐一传给函数。初始化列表对象只是一个指向一个array，并不会真正包含所有的数据。

9. 这样的话，一些stl算法就可以直接使用了。比如max({1,2,3})，这个新版本的函数可以接受任意个数的参数。

10. 如果声明之后直接一个大括号{}则表示这是给默认初始化为0。如果类中没有接收Initializer_list的构造函数，编译器会把参数拆解，如果拆解后的个数等于构造函数的个数，则仍可以，但是如果不相等，就会出错。

11. explicit关键字主要用在构造函数上，告诉编译器不要自作聪明。该关键字可以作用在只有单一实参的构造函数身上：有另外带默认值的参数不认为是一个单一实参，此时如果只传入一个值进入构造函数，那么编译器会做一个隐式转换。（如果有多个参数时，不存在这种隐式转换的问题。）隐式转换在旧版本只会在non-explicit one arguement ctors中有价值，但是在新版中，该关键字若在接受多个实参的构造函数中仍然有价值。ctors必须明确显式调用。 

12. for(int i:{1,2,3....,n})写法。

13. 新的全局函数begin()和end()可以接受容器对象。begin(vec)=vec.begin();

14. =delete,=default

15. alias template(template typedef)化名的意思。化名可以简化书写，但是失去了特化或者偏特化的能力。

    > template<typename T>
    >
    > using vec=std::vector<T,myalloc<T>>;
    >
    > 无法使用#define：纯粹的文字复制，里边的T无法替换。
    >
    > 无法使用typedef：因为它也不接受参数。

16. 化名的重要作用：能在模板中接收模板。

17. typedef与type alias等价。using func=void(*)(int,int)。

18. noexcept:异常，在函数后头写出这个关键字时，表示这个函数不会抛出异常。

    > void foo()noexcept(true);

    异常如果没有被及时处理：std::terminate->std::abort。

19. 在vector和deque中具有成长属性，它们的move构造和析构函数，一定不要抛出异常，如果vector和deque的move构造函数不是noexcept类型的时候，编译器不会调用它们。

20. override的作用是做出一个明显的提醒，防止写错(写成了被编译器认成了重载。)

21. final的作用是修饰类拒绝继承，修饰成员函数表示派生类不能覆写这个虚函数。

22. decltype(declaired type)可以找出一个表达式的type。比如你有一个容器的对象object, 就可以写decltype(object)::value_type elem;作用：返回函数或者变量的类型、以及返回lambda表达式的type。

    > decltype和auto都可以推断类型，但是有如下差异：
    >
    > auto忽略顶层const，decltype保留顶层const
    >
    > 对引用和解引用操作，auto推断出原有类型，decltype推断出引用
    >
    > auto推断时会有某些实际执行操作，但是decltype只做分析。

23. lambda表达式，允许定义一种inline函数，可以用来当成一个对象或者一个参数。比如说less<int>这样的仿函数，也可以用lambda实现。加一个小括号表示调用这个lambda对象。

24. lambda表达式：[]中说明传参数 是传值和传引用，然后要加上mutable关键字。编译器对于lambda产生的代码就是一个匿名类。

25. variadic templates中变化的是参数个数和参数类型。参数个数可以是利用参数个数逐一递减的特性实现函数的递归调用。参数类型也可以是利用参数个数逐一递减导致的参数类型也变换的特性。其中...的位置在声明与在函数体中是不一样的。一般会写一个只有一个参数的边界条件。

26. 可以使用sizeof...(args)来获取参数的个数。

27. void func(const T& firstArg,const Types&...args)与void func(typename... Types)是可以共存的，不会引发歧义的原因是第一个更加特化，所以下面的一个永远都不会被调用。比如重写C中的printf函数、接受任意参数个数的max函数。

28. 如果接受的参数是同一种类型，不必用variadic类型，直接用Initializer _list即可。如果不是相同的类型，就必须要用variadic templates+tuple的方式、或者用类模板的递归继承(private)。效仿递归继承的这种思想，可以用于递归复合。

#### 二、标准库

1. 左值：可以出现在赋值符号的左边，右值：只能出现在右边的值。但是也有例子会推翻上述的说法，比如右值放到了左边。
2. 不完美转发：在右值快递的过程中，被快递员发送到收件人手里时变成了左值。std::forward

​    

​    

​    