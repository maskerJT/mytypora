	【侯捷】内存管理机制

## 一、内存管理原始工具

1.malloc/free new/delete ::operator new/::operator delete allocate/deallocate

2.operator new能作为一个常规的函数被调用，比如`::operator new(*buf);`在C++中new是一种运算符，这个运算符先调用operator new(A)，然后在A中指定类型，然后会初始化或者构造这个对象A，最后再返回一个指向这个对象的指针。

> for example:
>
> A* a = new A；先由::operator new分配内存，然后调用A()构造函数，最后返回分配指针。

3.operator new有三种形式，plain new+nothrow new+ placemet new，分别表示抛出bad_alloc异常+返回null+返回ptr。第三种的placement new在内存池技术中有广泛应用。

4.在类中重新定义自己的operator new和operator delete （运算符重载）通常很有用，但是要注意的一点是**static**，原因是如果非static那么必须要一个对象实体才能调用这些函数，这与你本身new一个对象的前提是相冲突的。不过，C++是很体贴的想到了这一点，所以对于这两个操作符写不写static无所谓。

5.placement new允许将object构建在已经分配的内存中，没有placement delete,因为根本没有真正意义上的new。这种运算的对象是一个指针。体会以下写法：

> A* a = new A；
>
> Func* ptr=new(size_t,...)Func;//带小括号的就是placement new。第一参数一定是一个大小的整数。

6.为什么要在类中自定义new呢？

这是因为每new一个对象会携带一个cookie的开支，如果new一个对象数组的话，无疑会带来很大的开销。想办法把cookie变成一个。对于对象数组可以设定一个块中个数的大小，当new一个对象数组很大时，这些对象按块节省cookie。

7.union在operator new中的运用。embedded pointer.

8.因为上述的东西，没有泛化的功能，对于每一种类都要重写，所以static allocator出现了。

总结一下就是：

版本一是全局的一般的没有优化的；

版本二是加上了embedded指针的；

版本三是加上了allocator，把内存的动作抽取到一个class；

版本四是对于macro宏的运用。

9.标准库的allocator: 有16条free_lists可以应付16种不同的大小。

10.new_handler的存在意义：明知下一步马上要抛出bad_alloc时，会多次调用这个函数，让用户可以做一些补救措施以便于完成new；或者调用abort()/exit();

11.=default和=delete不仅可以作用于ctors和dtors，还可以作用于new/delete。

## 二、标准库的std::allocator

1.VC6使用的std::allocator中分配的粒度是对象，而gnu2.9中使用的是字节数。gnu4.9中有很多extended allocators在编制外。标准的反而会带cookie，而编制外的可能更优秀更精简(比如说分块连续)。

2.编制外std::alloc(继承自编制外的pool_allocator)每次都会要2*20个对象的大小(不带cookie)。如果单一对象的大小超过了 16x8=128,就会调用malloc，此时就会每个对象带cookie。

3.embedded pointer使用了union来避免cookie。

4.当对象的大小为a个字节，那么申请的量是`a*20*4+RoundUp(total)>>4`个字节。碎片的处理，当下一个申请到来，但是剩余量甚至不能承载一个对象时，会把剩余量放到除以8减去1的地方去。如果pool有20份的余量那么就切20份，如果没有就按照最大的切。RoundUp作用是内存对齐。

5.如果不能满足上式的要求获取申请量时，会到本应申请的链表内找残余，如果残余够一个的话那就先用一个，不都的话，将残余分到该去的地方，然后链表向后移动，看能不能从后边的链表中拿出空余的内存来顶上。如果移动到下标为15也没有能顶住的话，就已经完蛋了。在其他链表的下方即便还有空余的空间也不能做空间区域合并，因为技术难度太大了。refill(), chunk_alloc();

6.借鉴的地方：if(0==var);避免的地方：`obj* *p, *p1//实际上为obj** p1; obj* p2;`

7.反思：源于先天的设计缺陷，deallocate并没有将内存还给操作系统；为什么不把剩余量全拿走？为了其他线程考虑，不要吃光光。先天缺陷：指针作为union已经遗失，无法释放。

8.标准库中的容器中的分配器会带cookie。而编制外的poo_alloc一个很大的内存时带的cookie远远要更小。

## 三、malloc/free

1.sbh=small block heap;第一步的heap_init()中，包含了sbh_heap_init()；这个动作是生成一个16个大小的header链条。如果用完了就生成两倍大小的free-list。一个header负责管理1MB(16K管理cookie)。第二步是io_init()，这一步做申请了100h(256个字节)。单从这一步我们就知道了在主程序中如果申请一块内存，那么这块block的大小会roundup到16的倍数。

2.1M会被分成32个小块，每个小块为32K，每个小块又会被八等分，每一份就是4K，称为一个page。

3.16K的管理cookie中会有32个group逻辑单元，group逻辑单元中包含有64对指针，每个逻辑单元管理32K，也就是8个page。最后一对指针管理1K~4K的内存分配。

4.32组group单元还有一个连体兄弟，包含有32*64个bit，每个bit位来标识某个链表是不是挂了内存。也就是说`每个group的64对指针都会有64个bit来标识这64条链表的情况。`

5.实际上的申请步骤：程序要的大小+膨胀+debug header+cookie+16的roundup;

6.由于一个group的64对指针中，管理了8个page, 这些page起初是全部挂在最后一对指针上的，当有某一个动作释放了一块内存时，`这块内存会根据计算分派到64对管理的某一个位置下面去`。具体的计算方式是`释放的内存/16-1=该挂载的链表位置`。

7.一个block有上下两个cookie，设计的目的就是内存释放的时候可以判断能不能合并。没有下cookie就不能往上合并，系统就不理想。

8.free(p)的这个动作要找到p所在的header+内部的group+内部的free-list链表。

9.上述分段管理的妙处就是单位分的越小，就越容易回收给操作系统。

10.如何全部回收一个group呢？group顶上有一个counter：如果为0 标志着可以全回收。如果counter等于0 的时候这意味着所有的内存碎片已经全部合并了。全回收的状态就是初始状态，全部都链接在最后一个链表。但是这八页并不会立马还给操作系统，以防程序又有一些新的内存分配操作，它会等到又有一个group全回收了才会还一个给系统。这个现象叫做defering,也就是延缓回收。

11.所谓defer, 操作是借助一个叫sbh_pHeaderDefer的指针来实现的。这个指针指向一个全回收group的header。等到这个有第二个group全回收时，才会释放第一个defer，并将新出现的全回收group设为defer。如果尚未出现第二个全回收并且又要从找block来存数据的时候，就会取消这个defer。另外还有一个指针叫sbh_indGroupDefer，用来指示在header中的哪个group需要被全回收。

12.CRT：Heap State Reporting Functions，这些函数追踪内存的链表。

13.VC malloc与GCC allocator的关系：之所以后者一般最大支持128字节的对象元素，是为了去除cookie。后者的缺点就是它不愿意还给操作系统；

14.malloc下一层，也就是系统层面的API比如HeapAlloc、VirtualAlloc等也有类似的机制：内存池+自由链表。

15.总结：

`OS API----CRT(malloc/free)----C++ primitives(new ::oprerator new)----C++ library(std::allocator)----C++ Applications`。

16.对于VS来说，由于OS API能做铺垫的工作，因此VC10改版之后已经把原来的内存池机制下放到OS API了。

## 四、loki::allocator

1.gnu中容器的allocator内存不会返还给操作系统，而这个loki::allocator可以。

2.loki::allocator的层次为：`chunk---FixedAllocator---SmallObjAllocator`从低到高的结构。chunk这个结构用来存储基本信息：pDATA用来标记区块的位置，firstAvailableBlock参数用来表示接下来可供应的小块的index，blocksAvailable表示目前还可以供应几个小块。FixedAllocator是一个chunk的vector+两个指向内部元素的指针；SmallObjAllocator是FixedAllocator的vector，并且也带有两个指针。

3.每在chunk中使用一个小块时，其index会被拿走，并指向下一个可以使用的index，再将可以使用的块数减一。注意这里的index不是内存相邻意义上的index，而是链表上的串接关系。

4.FixedAllocator的两个指针，分别指向上次分配出去的chunk和上一次释放出去的chunk的位置。deallocator中有个vicinityfind()来找到应该释放的位置。找到之后会进行回收，但是也不一定是全回收，也会有延缓的动作。

5.总结：

> 精简强悍，手段暴力;
>
> 使用vector取代list，使用index取代pointer；
>
> 能够以很简单的方式判断chunk全回收，并且有defering的能力；
>
> 但是它植根于vector，在最初使用到了std::allocator.



## 五、其他主题

1.一个allocator最容易满足容器的做法是每当容器需要的时候就调用operator new，每当要释放内存就调用operator delete。优点：可以支持极大范围的硬件与操作系统环境，缺点是比预先分配一大块的方式更慢。对应的分配器就是`gnu_cxx::new_allocator`最粗浅地调用operator new/delete(课重载)。还有一个就是`gnu_cxx::malloc_allocator`与前面一个的不同之处在于调用的是C函数std::amlloc/free。

2.智能型allocator，比如fix-size pooling cache，如标准库中的allocator。还有一种bitmap index。这两种对应的分配器：`gnu_cxx::bitmap_allocator`+`gnu_cxx::pool_allocator`+`gnu_cxx::mt_alloc`+`gnu_cxx::debug_alocator`+`gnu_cxx::array_allocator`等。

3.array_allocator内部是一个静态数组，因此它内部的deallocator实际上是do nothing.

4.debug::allocatorta它是一个wrapper，调用内部的allocator时要多带一块冗余，作为cookie。

5.pool_alloc=G2.9使用的分配器std::alloc(`霸道不还`),而不是后来形成的标准库中的std::allocator(`必带cookie`)。

6.bitmap_allocator:一般只为每次申请一个的客户服务，每次也是两倍增长。用mini_vector的两个指针来指示头和尾。每个superblock都有一个mini_vector来操纵。每次新建的链应该是近似上条链的两倍。所以：`如果不发生全回收，规模倍增，如果有全回收则设计成分配规模减半`。bitmap_allocator有两条供应链，分别用来容纳使用中的以及全回收的。回收的供应链最多可以管理64个superblock。所以如果使用链中没有了容量，就会先从回收链中拿回合适的全回收链。



## 六、一些细节

1.const在成员函数中的使用，如果它出现在函数的参数列表(也就是小括号)之后，大括号之前，那就说明不可以改变对象中的数据。所以当一个类是const时，其中的成员函数如果要调用就一定要加const。

2.当成员函数的const与non-const版本同时存在时，常量对象只能调用const版本，而non-const对象只能调用non-const版本。

3.new/delete是一个表达式，它是不可以重载的，但是它内部调用的::operator new/delete却是可以重载的。当然也可以重载内部的成员函数operator new。如果使用想绕过成员函数而调用全局函数时，可以在创建对象的时候带上::。

4.new[]构造时要加上一个counter，记录个数。实际上成员函数的new/delete可以重载出很多个版本，只要每个版本有不同的参数列。比如：`void* operator new(...)`称为placemet new/delete。

5.需要注意的是，重载的这些delete绝对不会被默认调用，只有在new分配了内存，并且构造失败的时候才会调用这些重载的delete函数。



## 七、外部补充

1.第一级配置器直接使用malloc+free+relloc，在大于128B时使用；

2.如果小于128B，使用内存池，维护16个freelist，各自管理大小为8~128B长度的小额区块。

3.vector只有在插入的时候才会扩容，初始化的时候capacity就是size。

4.allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。

5.内存对齐八股文

6.memcpy和memmove的区别：后者会考虑会不会覆盖，如果覆盖那么从尾部开始复制。

7.**new**包含了三个过程：

`调用operator new分配内存`+`调用构造函数生成对象`+`返回相应指针`；

**operator new**在指定位置上构建对象，不需要额外分配内存，只需要调用构造函数。

综上：

```c++
new operator=operator new+placement new;
```

8.malloc需要人为计算字节数；calloc则不需要；realloc是在某个地址上忘记过去重新分配；

```C++
void* malloc(20*sizeof(int));
void* calloc(20,sizeof(int));
void* realloc(void*p,newsize);
```

9.malloc与free的实现原理？

> 1、 在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk、mmap、，munmap这些系统调用实现的;
>
> 2、 brk是将数据段(.data)的最高地址指针_edata往高地址推,mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；
>
> 3、 malloc小于128k的内存，使用brk分配内存，将_edata往高地址推；malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配；brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩。
>
> 4、 malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。





























