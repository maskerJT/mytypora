## 深入理解linux内核

### 第一章

### 第四章

1.同步和异步中断称为异常和中断。

<img src="https://img-blog.csdnimg.cn/20200315003251844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZ2VsRGc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

**核栈映堆数代**

2.栈的静态分配是由编译器完成的，动态分配是由alloca分配的，也是在系统的栈内。alloca在栈上分配内存。

3.堆和栈的区别？

> **管理方式+空间大小+碎片问题+生长方向+分配方式+分配效率**

栈内存是编译时可以确定的内存，堆内存是运行时动态申请的内存。



### 编译和链接

#### 编译连接攻略

**预处理－－>编译－－>优化－－>汇编－－>链接-->可执行文件**

![图片2](https://images0.cnblogs.com/blog/412433/201405/292249100095523.png)

> 预处理：gcc -E hello.c -o hello.i   所有带#的都要处理=**头文件展开+宏定义进行替换+条件编译去除**
>
> 编译：  gcc -S hello.i -o hello.s   语法检查，打开里边是汇编程序
>
> 汇编：  gcc -c hello.s -o hello.o   生成二进制目标程序 file命令
>
> 链接：  gcc hello.o -o hello        把函数在哪的信息链接进来，运行的时候去找到要使用的信息（动态链接）
>
> ​        gcc hello.o -o hello -static 把函数的实现的二进制代码直接复制到最后的可执行程序中  

> **其他的参数**
>
> -g 使用gdb进行单步调试    -v 打印编译器版本信息
>
> -I 头文件搜索路径         -L 库文件搜索路径
>
> -static 链接静态库        -l 链接库文件

> **库的制作**
>
> - 静态库libxxx.a 
>
>   - 生成静态库：ar -crv libxxxx.a(xxxx是名字，前后缀是固定的)
>
>   - 其他目标程序如要静态链接：gcc hello.c -o hello -static -L pathToLib -l xxxx
>
> - 动态库
>
>   - gcc -fPIC -shared -o libxxxx.so sources.c  ldd命令

1.联编：一个计算机程序的不同部分彼此关联的过程。

动态联编又叫动态绑定，是由C++的虚函数带来的。静态联编又叫早期联编，解决的是程序调用操作与代码之间的关系。

2.编译+汇编：源程序产生目标程序的过程。

静态编译：在编译可执行文件时，把动态链接库的部分提取出来，链接到可执行文件中去，使得运行时不需要依赖dll；

动态编译：运行时附带dll,能缩小可执行文件的大小，加快编译速度；

3.链接

静态链接：lib中的代码直接链接进目标程序；动态链接把要调用的函数与dll的位置链接进目标程序；二者都是共享代码的方式；区别：lib不能再包含其他lib或者dll,但是dll可以包含其他的lib与dll;当存在多处对lib/dll中函数的调用时，lib会产生多份拷贝，dll只产生一份拷贝。 





### 计算机大小端

1.虽然大端反直觉，但是好处是能立马知道数据的正负。

![img](https://pic1.zhimg.com/80/v2-f163d48ca510081e0f8b7545053c1f5f_720w.jpg?source=1940ef5c)

2.检测方式

> **char读取int的低位+union读取char成员+reinterpret读取**



3.hello world全过程：

> 双击或者cmd中运行exe
>
> OS找到exe的相关信息，确定代码和数据在exe中的位置并计算出对应地址。
>
> OS新建进程，并将exe映射到该进程结构；
>
> OS设置cpu上下文环境，获取执行代码；
>
> OS执行第一条指令发生缺页异常，因此分配一页物理内存，继续执行。
>
> exe执行系统调用在显示器写一字符串；
>
> OS送往显示设备，并转成像素存入缓冲区。
>
> 解码器转换成数据信号，显示器解释信号并激发液晶屏。



### 系统调用

应用程序无法直接执行内核代码，它通过软中断来通知系统，告诉内核自己需要执行一个系统调用，希望系统切换到内核态，这样内核就可以代表应用程序在内核空间执行系统调用。

`软中断`应用程序通过引发一个异常来促使系统切换到内核态。通过中断号来执行异常处理程序，但是仅仅陷入内核是不够的，还需要告诉内核`系统调用号`：在陷入内核之前，先把系统调用对应的系统调用号放在eax寄存器中。还有其他的别的寄存器可以存放系统调用需要传递的`参数`;

实现系统调用：考虑因素：向后兼容+可移植等；在接收用户程序的指针之时，内核必须保证：指针指向的内存区域只能是用户空间的内存区域，不能是内核空间或者是其他进程的地址空间。

当编写完一个系统调用以后，首先需要在系统调用表的最后加入这一项；然后把系统调用的这个函数放到适合的c文件中去；新加入一个系统调用号的利弊：

好处是带来高性能和使用方便，坏处是难以维护和更新。



### 内核数据结构

#### 链表

1.在内核的数据结构中嵌入了一个链表的数据结构。通过指针偏移可以获取这个父结构体的任意变量，通过container_of宏还可以获取父结构体。

2.内核链表最杰出的特性是，每个节点都是无差别的，可以从任意一个节点起遍历链表。而如果我们需要一个特殊的指针索引到整个链表的话，它其实就是一个常规static的链表数据结构。

3.从链表中增加一个节点是非常简单的，但是删除的时候并不会立马释放这个数据结构，你可以再决定释放内存还是进行复用。

4.此外还有遍历、遍历时删除等宏。



#### 队列、映射

1.映射也就是关联数组，虽然散列表是一种映射，但是并不是所有的映射都需要通过散列表实现：AVL和红黑树等。虽然哈希表能提供更好的平均渐近复杂度，但是二叉搜索树在最坏的情况下有更好的表现，并且它不需要散列函数、能保证顺序，可以给按序遍历带来好处。

2.内核中的idr数据结构用来将用户空间的UID映射到一个指针上，UID是一个唯一的标识数。在内核中，当调用者给出一个UID时，idr要返回其对应的指针。

### 中断和中断处理

1.变内核主动为硬件主动。

2.异常是内核中产生的同步中断，中断是硬件产生的异步中断。

3.在响应一个特定中断的时候，内核会执行一个函数，称为中断处理程序ISR，产生中断的每个设备都有一个中断处理程序，一个设备的中断处理程序是它驱动设备的一部分，设备驱动程序是用于对设备进行管理的内核代码。中断处理程序与其他内核函数的区别在于它是被内核调用来响应中断的，运行于中断上下文中。

4.中断可能会存在上半部与下半部的任务。

5.中断处理程序的注册：需要分配一个中断号以及一个实际中断处理程序。卸载驱动程序时，可以注销响应的ISR。

6.下半部=工作队列+软中断+tasklet.

### 内核同步

1.所谓临界区就是访问和操作共享数据的代码段，为了避免在临界区中发生并发访问（其他程序也在操作这个共享数据），我们需要保证临界区中的代码是原子地执行的。如果

多线程访问同一个资源，对这个访问顺序是敏感的，那么就称存在竞态条件。

### 内核同步的方法

1.原子操作：内核提供了两组原子操作接口，一组针对整数进行操作，另外一组对单独的位进行操作。这样确保了其他改变内存的操作不能同时发生。原子操作最常见的用途是实现计数器

2.自旋锁：自旋锁的实现与体系结构密切相关，往往通过汇编实现。自旋锁在同一时刻最多被一个执行线程持有，它可以用在中断处理程序中；

3.读写自旋锁：如果对数据的操作可以被划分成读取和写入两个场景，比如生产者和消费者。

4.信号量：linux中的信号量是一种睡眠锁，如果有任务视图获取一个已经被占用的信号量时，信号量会把这个程序推进一个等待队列，然后让它睡眠，这个时候处理器可以重获自由，当信号量被释放的时候，处于等待队列中的程序会被唤醒，从而获得这个信号量。它提供了比自旋锁更好的处理器利用率，但是比自旋锁有了更大的开销。

可以在持有信号量的时候睡眠，不同于自旋锁，内核可以抢占，这意味着信号量不会对调度的等待时间带来负面影响。一般是在很底层的特殊场合才会使用信号量，因此最好还是使用互斥体。

5.互斥体MUTEX ，信号量适用于复杂的，未名情况下的互斥访问，比如内核当中用户空间的复杂交互行为。这也意味着为了简单的锁定而使用信号量并不方便。它与使用计数为1的信号量类似，但是接口更加简单，更加高效使用的限制更强。一般在中断上下文中只能使用自旋锁，而在任务睡眠时只能使用MUTEX。

6.完成变量：如果一个任务要执行一些工作时，另一个任务就会在完成变量上等待。当某个任务完成工作以后，就会使用完成变量，去唤醒等待的任务，事实上，它跟信号量非常像，是一个简单的替代解决方案。

7.大内核锁BKL：是一个全局自旋锁，使用它仅仅是为了从最初的SMP过去到细粒度加锁机制。

8.顺序锁：跟读写锁非常相似，不过更加适用于读多写少的场合，它对写操作赋予了更高的优先级：写锁总是能够被成功获得；读数据的时候，先读取序列号，如果是奇数表示正在被写，那么就再读一次。

9.禁止抢占：使用自旋锁或者调用内核禁止函数。内核抢占时可能会在同一个临界区中运行。

10.顺序和屏障：多处理器或者硬件设施之间的同步问题。防止编译器对代码的顺序 产生优化或者重新编排。提供了一个屏障：之前的代码不会在屏障之后执行，之后的代码也不会在屏障之前执行。





### 定时器和时间管理

1.系统定时器频率，采用可编程中断时钟：节拍率，通过静态预处理定义，系统定时器通过这种频率自行触发时钟中断：高节拍率的优劣：

优势：更高的时钟解析度+提高了时间驱动的事件的准确率+进程抢占的精确度；

劣势：系统的负担越重，更频繁地处理ISR，增加耗电。

2.系统的实时时钟RTC，关机后时还能用；jiffies全局变量与用来记录自系统启动以来产生的节拍总数；

3.内核代码代码除了使用定时器或者下半部机制以外，还需要其他方法来推迟执行某些任务。比如忙等待+短延迟+schedule_timeout方法。

4.短延迟：内核中提供了三个可以处理到纳秒级别的延迟函数，它们通过执行循环而达到延迟效果。

5.schedule_timeout方法会让需要延迟执行的任务睡眠到执行的延迟时间后再重新运行，但是也不能保证睡眠时间正好等于指定的延时，只能尽量时延迟时间耗尽后再重新运行。



### 内存管理

1.由于内核不能像在用户空间中那样奢侈地使用内存，所以它不支持简单便捷的内存分配方式。

2.linux把系统的页划分为区，形成不同的内存池，这样就可以根据用途进行分配。区有ZONE_DMA（ZONE_DMA,32）, ZONE_NORMAL, ZONE_HIGHMEM分别表示DMA使用的页、正常可寻址的页以及动态映射的页。

3.不是所有的体系结构都定义全部的区，比如Intel的x86-64体系结构可以映射和处理64位的内存空间，所以它没有ZONE_HIGHMEN区。

4.linux中有分配连续物理页的函数，以及获得填充为0的页的函数，以及页的释放。

5.分配内存页时，有三种分配器标志，分别是行为修饰符、区修饰符和类型；**行为修饰符**表示内核应当如何分配所需的内存+**区修饰符**指定到底从这些区的哪一个区中进行分配。类型标志指定所需的行为和区描述符来完成特殊类型的处理。

6.vmalloc=确保页在虚拟地址空间中是连续的；

kmalloc=确保页在物理地址上是连续的（虚拟空间中也必然是连续的）。

7.出于性能的考虑，一般内核代码是使用kmalloc，vmalloc为了把物理上不连续的页转换为虚拟空间中连续的页必须专门建立表项。vmalloc一般在不得已的时候才会使用，比如为了获得大块的内存。

8.分配和释放数据结构是所有内核中最普遍的操作之一，为了便于数据的频繁分配和回收，常常会用到空闲链表，它相当于对象告诉缓存，能快速存储频繁使用的对象类型。linux内核中提供了slab层，slab分配器则扮演了通用数据结构缓存层的角色。

9.一般每个进程都有两页的内核栈，也是就说32位和64位的机器中，每个进程的内核栈的大小分别是8KB和16KB。在历史上，中断处理程序ISR和被中断进程共享一个内核栈，但是如果被中断的进程只有一页的内核栈时，其中断处理程序会有一页额外的内核栈，从而光明正大的在自己的中断栈上工作。



### 虚拟文件系统VFS

1.VFS可以使得用户直接使用同一的系统调用而无需考虑文件系统和实际物理介质。之所以可以使用这种通用接口对所有类型的文件系统进行操作是因为在内核中它的底层文件与系统接口上建立了一个抽象层。即便不同的文件系统在功能和行为上存在很大的差别。

2.抽象层：VFS定义了所有文件系统都支持的、基本的、概念上的接口和数据结构。

3.VFS有四个主要的对象类型，分别是：超级块+索引节点+目录项+文件（对象）；

4.超级块对象用于存储特定文件系统的信息；

5.索引节点对象包含了内核在操作文件或者目录时需要的全部信息。

6.目录项对象没有对象的磁盘数据结构，它根据字符串的形式当场创建。

7.文件对象：表示进程已经打开的文件，进程直接处理的是文件。



### IO层

1.系统中能够随机访问固定大小的数据片的硬件设备称为块设备，这些固定大小的数据片就叫做块。

2.如果一个硬件设备是以字符流的方式被有效访问，像串口和键盘就属于字符设备。

3.上述两种设备的区别在于是否可以随机访问数据。

4.块设备中最小的可寻址单位是扇区，它是2的整数倍，并且要小于页面大小。块是扇区的整数倍，它是文件系统的最小寻址单元。



待完善



### 进程地址空间

1.内核除了管理本身的内存以外还有管理用户空间中的内存，称为进程地址空间。Linux采用虚拟内存技术，因此系统所有进程之间通过虚拟内存的范式共享内存。

2.内核使用内存描述符结构体表示进程的地址空间。内存描述符mm_struct中能记录使用该地址的进程数目，同时也有一个主引用计数器。内核同时使用这两个变量是为了区别主从技术器和使用该地址空间的进程的数目。

3.当父进程希望和子进程共享地址空间时，可以调用clone复制父进程的内存描述符，并设置clone_VM标志位，当这个标志位被指定以后，内核就不必再调用alloc函数而是仅仅只需要将指针指向父进程的内存描述符即可。这种clone得到的就是linux中的线程。除此之后，linux内核并不区别对待它们，从内核角度看，它们仅仅是共享了特定资源的进程而已。

4.撤销内存描述符时会更新一些统计量比如引用计数等，然后再将这个描述符归还给slab。

5.与用户空间不同，内核线程没有相关的内存描述符，没有用户上下文。为了避免内核线程为内存描述符和页表浪费内存，也为了当新内核线程运行时，避免浪费处理器周期向新地址空间进行切换，内核线程直接使用前一个进程的内存描述符。

6.虚拟内存区域VMA，由一个虚拟结构体描述，制定了地址空间内一个独立的内存范围



### 页高速缓存和页回写

1.在读操作中，缓存的作用可以是缓冲命中的，从而集体提升数据获取效率。

2.在写操作中，缓存一般被实现成三种策略之一：

> 不缓存：当对一个缓存中的数据进行写操作时，跳过缓存，直接往磁盘里面写。
>
> 写透缓存：更新缓存以及磁盘文件，缓存和后备数据保持同步；
>
> 回写：linux采用回写机制，程序的写操作直接写到缓存中，后端存储不会立马更新，而是将页高速缓存中的被写入的页面标记为“脏”，将其加入到脏链表中，然后由一个回写进程，周期性的把脏页链表汇总的页回写到磁盘。最后在清理脏页标识。

3.缓存回收：决定缓存是什么时候清除数据。

> 最近最少使用：LRU，它需要跟踪每个页面的访问踪迹，一遍能够回收到最老的页面。
>
> 双链策略：linux采用。维护的不再是一个LRU链表，而是两个链表：活跃链表和非活跃链表。

### 设备与模块

1.linux中设备分为三种：块设备+字符设备+网络设备。

2.Linux内核是模块化组成的，好处是基本的内核可以尽可能的小，可选的功能和驱动可以利用模块的形式提供。







































































