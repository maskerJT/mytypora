### 高性能mysql 

1.ACID标准特性；atomicity consistency isolation durability

2.四种隔离级别：未提交读+提交读+可重复读+可串行化

3.锁粒度：表锁+行级锁；

4.







### Redis

1. 在是否使用Redis的这个问题上，一般要考虑以下几个问题：

   **业务数据命中率+读写操作次数+业务数据的大小**





### UML图





### 一、Mysql基本架构

1.事务的ACID特性**=atomicity consistency isolation durability**.

2.四种隔离级别：未提交读+提交读(一般数据库)+可重复读（mysql）+可串行化

3.死锁：两个事物各自占据一个资源，然后索要对方的资源。

4.事务日志：修改行为只改变内存和事务日志，事务日志持久之后从后台修改到磁盘。

5.多版本并发控制MVCC，可以认为它是一个行级锁的变种，但是在很多情况下可以避免加锁操作，因此开销更低，虽然实现机制不同，但是大多都实现了非阻塞的读操作，写操作也只锁定必要的行。不同引擎的MVCC不同，典型的有乐观和悲观并发控制。

6.InnoDB是mysql默认的事务型引擎。

7.InnoDB采用MVCC支持高并发，默认是可重复读的隔离级别，并通过间隙锁防止幻读。

8.MyISAM是5.1以前的版本默认存储引擎。它不支持事务和行级锁。并且崩溃后无法安全恢复。

9.Mysql内部的其他引擎，archive、blackhole、CSV等。

### 二、基准测试

1.分为集成式和单组件式的测试。

2.测试指标：吞吐量+响应时间或者延迟+并发性+可拓展性

3.测试工具，有很多测试工具。如果没有做过基准测试，建议至少要熟悉sysbench。

### 三、服务器性能剖析

1.性能定义为完成某件任务所需要的时间度量。

### 四、SCHEMA和数据类型优化

#### 1.选择优化的数据类型

1.1  整数可以是8到64位不同的存储空间范围。

1.2实数类型是带有小数部分的数字，float、double、decimal等。

1.3字符串类型varchar，char;varchar比char更节约空间，因为它值使用必要的空间。当存储char的时候，mysql会删除所有的末尾空格。BLOB和TEXT是为了存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。

1.4时间和日期类型 如year/date，能储存的最小时间粒度为秒，但是可以使用微妙级的粒度进行临时运算。

1.5位数据类型，所有的位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型。有BIT+SET等。

1.6选择标识符，为标识列选择合适的数据类型非常重要，标识列可以与其他值作比较或者通过标识列寻找其他列，也可以作为表中的外键使用。小技巧：使用整数类型可以自增；enum和set类型用来存固定信息，比如性别，类别等 。尽可能避免使用字符换类型作为标识列等。

1.7特殊类型如低于秒级的时间戳。

#### 2.一些设计陷阱

2.1太多的列：由于行缓冲之后再解码成各个列

太多的关联：如果希望插叙执行地快速并且并发性好，单个查询最好在12个表以内做关联。

过度使用枚举或者变相的枚举

#### 3.范式和反范式

3.1范式化的数据库：每个事实数据只会出现一次，反范式化的数据库信息是冗余的，可存储在多个地方。

3.2范式：

优点：更新更快+修改较少+表更小操作更快+更少的使用group场景。

缺点：通常需要关联

3.3反范式：

优点：很好地避免关联

缺点：扫描到无用的信息，导致效率低下。

3.4一般是范式和反范式混用

#### 4.缓存表和汇总表

缓存表存储每次从其他表获取但是速度比较慢的数据的表；汇总表是保存使用group by语句聚合数据的表。

4.1物化视图预先计算并存在磁盘上的表。

4.2计数器表。

#### 5.加快ALTER TABLE操作的速度

5.1用于在已有的表中添加修改或者删除列。

5.2只修改frm文件+快速创建myISAM索引等。

### 五、创建高性能的索引

#### 1.索引

也叫做键，是存储引擎用于快速找到记录的一种数据结构，索引非常关键。

1.1索引类型：

B树索引：实际上很多存储引擎使用的是B+树；它意味着每一个叶子页到根的距离相同。能够加快访问数据的速度原因是不再需要全表扫描，而是从根节点开始搜索；

哈希索引：基于哈希表实现，只有精确匹配索引所有列的查询才有效。缺点：无法排序；

空间数据索引R-tree/全文索引等其他索引。

1.2索引的优点：

`减少服务器扫描的数据量+避免排序和临时表+将随机IO变为顺序IO`

#### 2.高性能索引策略

2.1独立的列：不要在条件里把索引复杂化；

2.2前缀索引和索引选择性：如果索引很长的字符串，会让索引大且慢。此时可以索引开始的部分字符，大大节约索引空间，从而提高索引效率。这样也会使得它不再是唯一索引，大大降低索引的选择性：不重复的索引值（基数）/数据记录总数的比值。

2.3多列索引：这并不是为每个列创建单独的索引，或者按照错误的顺序创建多列索引。MySql中引入“索引合并”一定程度上可以使用多个单列索引来定位指定的行。这种算法包括：

OR条件的联合UNION

AND条件的相交INTERSECTION

以及上述两种情况的组合。

索引合并有是有是一种优化的结果，但是实际上更说明了表上索引的糟糕：

> 当对多个单列索引做相交时就要考虑构建多列索引；

2.4合适的索引顺序：将选择性高的索引放在索引的最前列，不过这条经验非常依赖选定的具体值。

2.5聚簇索引：不是一种单独的索引结构，而是一种数据存储方式，它依赖于不同的实现方式，InnoDB实际上是在同一个结构中保存了B树索引和数据行。找到索引就找到了数据。

优点：可以把相关的数据保存在一起+访问数据更快

缺点：聚簇能提高IO性能，如果数据在内存中，那么聚簇索引的优势就没了+插入速度严重依赖插入顺序（因为不是主键索引）+更新聚簇索引的代价很高+插入新行的时候可能面临页分裂+导致全表扫描变慢等。

2.6覆盖索引：一个索引包含或者说覆盖所有需要查询的字段的值，称之为覆盖索引。

优点：减少数据量访问（只需要读取索引即可）

2.7使用索引扫描做排序：Mysql有两种方法生成有序的结果：排序操作或者按索引排序来扫描数据。扫描索引本身是很快的，因为它本身就是一个数据结构，只需要从一条索引记录移动到紧接着的下一条记录。（只有索引的列顺序与order-by子句的顺序完全一致时才能使用索引对结果排序。）

2.8前缀压缩索引：通过压缩可以让更多的索引放到内存中；相同前缀字符串时只保存这个前缀，然后只需要存后缀即可。

2.9冗余和重复索引、未使用的索引都可以考虑优化。

2.10索引和锁：索引可以让查询锁定更少的行，如果更多的行上锁：额外开销+增加锁争减少并发；

#### 3、优化排序

3.1如果一个用户要搜索到的第10000页，反范式化、预先计算、缓存是可能解决这类查询的仅有策略；一个更好的办法是限制用户能够翻页的数量。另外一个策略是使用延迟关联：通过使用覆盖索引查询返回需要的主键，然后再根据这些主键关联表获得需要的行。

#### 4、维护索引和表

4.1维护表的目的：找到并修复损坏的表+维护准确的索引统计信息+减少碎片；

4.2如果损坏的是索引，可以将数据导出一份，然后再重新导入；如果损坏的系统区域，可以从备份中恢复表，或者从损坏的数据文件中尽可能地恢复数据。

4.3减少索引和数据的碎片：数据碎片有：行碎片+行间碎片+剩余空间碎片；

### 六、查询性能优化

#### 1.慢查询

1.1大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化：查询了不必要的记录、多表关联时返回全部列、总是取出全部列等。





























































































































































































