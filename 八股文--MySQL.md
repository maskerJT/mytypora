### 提纲版

1.MySQL的架构和一个sql语句的请求过程；

2.InnoDB和MYISAM的区别：事务+外键+索引+锁粒度+自增重启+全表计算

3.MySQL的数据类型：整形+浮点型+字符串型+日期型+其他（binary+point+geo+enum）

4.索引的优劣势：IO+CPU；空间+增删改

5.索引的分类？

- 数据结构的角度

  > B+树、hash、R树、full-text

- 物理存储的角度

  > 聚簇索引、非聚簇索引

- 逻辑角度

  > 主键索引、单列索引、联合索引、唯一索引

5.B树与B+树的区别？

M阶代表每个节点最多包含M个孩子；

- B树

  > 1.中间层结点最多有M个儿子，M>2;
  >
  > 2.中间层节点的儿子数范围为[M/2,M]向上取整；
  >
  > 3.K个关键字指向了K+1个儿子。
  >
  > 4.在B树中的关键字不会重复。
  >
  > 5.所有叶子结点位于同一层（多路平衡树）。

- B+树

  > 1.有两个头指针分别指向根节点和最小关键字结点。
  >
  > 2.这些关键字不携带数据，只用来索引，数据全在叶子；
  >
  > 3.根节点的最大元素就是b+树的最大元素。
  >
  > 4.结点中包含所有儿子中的最大关键字。
  >
  > 5.K个关键字指向了K个儿子；

- b+树的优势

  > 层级更少，更矮胖，磁盘页能容纳更多元素。
  >
  > 必须查询到叶子结点，所以查询时间比较稳定。B树在某些情况下会更快。
  >
  > 范围查询时，B+树只需要遍历叶子链表，B树需要不断中序遍历。
  >
  > 天然具备排序功能。
  >
  > 叶子结点存在链指针，全节点遍历更快。

6.MyISAM和InnoDB之间的文件组成以及B+ 树的区别？

- MyISAM中有三个文件分别是frm+MYD+MYI，分别是元数据，数据，索引。

  InnoDB中只有两个文件分别是frm+ibd,分别是元数据，数据与索引。

- MyISAM存储【索引和指向文件的指针信息】；InnoDB存储【索引以及指向主键索引的指针信息】。

7.MyISAM和InnoDB的主键索引和辅助索引的区别？

- MyISAM

  > 非聚簇索引：索引和数据文件分离，所以【主键索引】和【辅助索引】的效果差不多，只是辅助索引可以有重复的关键字。
  >
  > 索引文件中的叶子结点key-value对中的value存储着数据的物理地址偏移量，属于随机访问，速度比较快。
  >
  > 【查询过程】通过索引文件查找关键字所在的节点，拿到文件指针和物理偏移量，从而定位数据。

- InnoDB

  > 聚簇索引：主键索引和数据放在了一个文件中。【主键索引】和【辅助索引】效果不一样。
  >
  > 辅助索引：最底层的叶子结点存了两行数据，分别是【按照ascll码值】排序的辅助索引+主键索引。
  >
  > 回表查询：先由辅助索引查找主键索引，再使用主键索引查找。
  >
  > 索引覆盖：如果只查询主键索引和二级索引的值，就不再需要回表。

8.为什么推荐使用自增主键而不是UUID？

- 自增主键的优点

  > - 更短
  > - 自增方便排序
  > - 顺序插入，有利于存储和页面使用率、减少页分裂和碎片的产生。

- 自增主键的缺点

  > - 被爬取的时候很容易根据自增主键获取业务增长信息。
  > - InnoDB插入的时候，容易造成主键上界的间隙锁争用。
  > - 自增主键可能造成自增锁的争用。

9.SQL注入式攻击

​	SQL命令插入到Web表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。使得语句提前结束或者提前注释等。

10.Hash索引：

MySQL中的Memory引擎和NDB引擎支持哈希索引。

缺点：无法进行区间查询；不支持联合索引的最左匹配规则；如果有大量重复键值，效率会很低。

10.创建索引的时机

- 需要创建索引：外键频繁排序高并发

  > 主键索引存在时会自动创建唯一索引
  >
  > 频繁查询的字段可以设置索引
  >
  > 与其他表产生关联的外键可以设置索引
  >
  > 有排序需求的字段建立索引
  >
  > 高并发下倾向创建组合索引
  
- 不需要创建索引：少长删改重复where

  > 表记录太少
  >
  > 表经常删改
  >
  > 表数据重复多的字段
  >
  > 很长的字段
  >
  > 已经存在很多索引的表
  >
  > 没有啥使用场景的字段

12.exist与in的区别？

> 1 

13.SQL的执行顺序？

- 语句顺序

  select | distinct | from | join on | where | group by | having | order by | limit

- 操作顺序

  from | on  join | where | group by | having | select | distinct | order by | limit

14.Join分类

- 内连接 inner join=join取两张表的公共部分
- 交叉连接 cross join=笛卡尔积，两张表的并集
- 外连接 left outer join=left join；right outer join=right join；取某一边的所有满足条件的元素。

15.并发事务处理可能带来的问题：

> - 更新丢失：不知道其他事务的存在，同时更新某个内容。
> - 脏读：读了将回滚的事务的数据。
> - 不可重复读：多次读取数据的时候，中间被其他事务改变了，导致数据前后不一致。
> - 幻读：多次读取的时候，中间被其他事务新增了数据，多了一些原本不存在的记录。

16.解决办法：

> 事务的隔离机制（ACID）=加锁+MVCC
>
> 锁的种类：读锁+写锁+间隙锁+行锁+表锁；

17.事务的隔离级别：

> 读未提交+读已提交+可重复读+串行化

18.MVCC

> - MVCC用到了一致性视图（快照），用于支持可重复读和串行化。
>
> - MVCC的核心=事务版本号+表的隐藏列+undo log+read view
>
>   - 事务版本号：每次事务开启都会从数据库获取一个自增长的事务ID，可以从这个ID判断事务的先后执行顺序。
>
>   - 表的隐藏列：**DB_TRX_ID:** 记录操作该数据事务的事务ID；
>
>   ​	   				 **DB_ROLL_PTR：**指向上一个版本数据在undo log 里的位置指针；
>
>   ​						**DB_ROW_ID:** 隐藏ID ，当创建表没有合适的索引作为聚集索引时，会用它创建聚集索引;
>
>   - undo log：记录被修改前会把数据拷贝到undo log，一旦要回滚，可以通过undo log还原数据。
>   
> - 实际上InnoDB并不会存储多个版本的数据，而是借助undolog记录每次写操作的反向操作，所以索引上记录的只会是最新版本。我们可以根据undolog的记录反向操作得到数据的历史版本。

19.事务日志

- redolog

  事务开启时，事务中的操作都会写到日志当中，并且会写到磁盘中进行持久化。事务提交之后，才会从内存缓冲区中写入到磁盘中。如果系统重启时，就可以通过redolog把数据库恢复到崩溃前的一个状态。

- undolog

  除了记录重做日志，还会做一定量的undolog，记录着每次写操作的反向操作，可以提供回滚操作。

- others

  错误日志、查询日志、慢查询日志（把所有超过阈值的语句写到其中）、二进制日志、中继日志、事务日志等。

20.分布式事务

两阶段提交：第一阶段：所有事务节点开始准备，告诉事务管理器；

​					第二阶段：事务管理器告诉节点应该提交或者回滚；某一个节点失败则所有的节点都要回滚来保障原子性。

21.三个范式

- 第一范式：库中的表的字段都是单一不可再分的；
- 第二范式：非主属性完全函数依赖于码；有且仅有一个主键，其他属性完全依赖于主键；
- 第三范式：非主属性既不部分依赖于码，也不传递依赖于码；[资料](https://www.cnblogs.com/simpleyou/p/11629112.html?ivk_sa=1024320u)

22.MySQL分区、分库、分表



23.百万级的数据如何删除？

24.分库分区分表的原因？

> 用户请求过大+单表数据过大+单库数据量过大

25.介绍一下分区？

mysql的InnoDB引擎的数据存在两种文件中，分别是ibd和frm,通过分区可以把一个表中数据不同的行分到不同的物理文件中去，分区是一个将表和索引分解成更多更小的、更可管理的部分，这是mysql支持的功能，在业务层的代码无需改动。

目前支持的分区类型：

- range分区（连续值）：将数据分成若干个连续的区间范围，根据落点确定数据的存放位置。
- list分区（离散值）：分区的定义是值列表中的某个值。
- hash分区：根据用户自定义的哈希函数进行运算，根据运算结果划分为不同的分区。
- key分区：使用系统提供的hash函数分区，复杂度可能大一些。

分区的缺点：

对分区表进行DDL或其他运维操作难度大风险高；

很难进行关联查询；

本质还是在一台机器上进行的，如果需要分区其实就代表着该机器性能无法满足了。

26.分表？

分表是出现在分区之前的解决大表问题的方式，水平分表的方式可以使用更加便捷的分区来代替，但是垂直分区是无法取代的。另外分表是用户层通过代码来实现的。分表不像分区，它是实际的每张表都有表该有的配套设施。分表可以出现在不同的数据库中。

垂直拆分：按照业务的使用频次，将主要的、热门的字段放在一起作为主表，把其他作为次表。

水平拆分：根据字段的不同，或者范围的不同对表进行水平拆分。

27.分库？

mysql开源且免费，拓展的成本较低。从根本上解决单台服务器性能不够的问题。

水平分库：与水平分表类似，将单个库中的表制作水平分表，然后放在不同的子库当中，独立部署。

垂直分库：拆分的不是字段，而是一个库中的不同表分到不同的数据库中去。

28.分表分库的缺点？

- 事务管理出现困难，利用分布式事务协调不同库之间的原子性。
- 跨库跨表的问题：尽力避免，在代码中通过多次查询完成。
- 额外的管理和维护负担。

















### 一、Mysql基本架构

1.事务的ACID特性**=atomicity consistency isolation durability**.

2.四种隔离级别：未提交读+提交读(一般数据库)+可重复读（mysql）+可串行化

3.死锁：两个事物各自占据一个资源，然后索要对方的资源。

4.事务日志：修改行为只改变内存和事务日志，事务日志持久之后从后台修改到磁盘。

5.多版本并发控制MVCC，可以认为它是一个行级锁的变种，但是在很多情况下可以避免加锁操作，因此开销更低，虽然实现机制不同，但是大多都实现了非阻塞的读操作，写操作也只锁定必要的行。不同引擎的MVCC不同，典型的有乐观和悲观并发控制。

6.InnoDB是mysql默认的事务型引擎。

7.InnoDB采用MVCC支持高并发，默认是可重复读的隔离级别，并通过间隙锁防止幻读。

8.MyISAM是5.1以前的版本默认存储引擎。它不支持事务和行级锁。并且崩溃后无法安全恢复。

9.Mysql内部的其他引擎，archive、blackhole、CSV等。

### 二、基准测试

1.分为集成式和单组件式的测试。

2.测试指标：吞吐量+响应时间或者延迟+并发性+可拓展性

3.测试工具，有很多测试工具。如果没有做过基准测试，建议至少要熟悉sysbench。

### 三、服务器性能剖析

1.性能定义为完成某件任务所需要的时间度量。

### 四、SCHEMA和数据类型优化

#### 1.选择优化的数据类型

1.1  整数可以是8到64位不同的存储空间范围。

1.2实数类型是带有小数部分的数字，float、double、decimal等。

1.3字符串类型varchar，char;varchar比char更节约空间，因为它值使用必要的空间。当存储char的时候，mysql会删除所有的末尾空格。BLOB和TEXT是为了存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。

1.4时间和日期类型 如year/date，能储存的最小时间粒度为秒，但是可以使用微妙级的粒度进行临时运算。

1.5位数据类型，所有的位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型。有BIT+SET等。

1.6选择标识符，为标识列选择合适的数据类型非常重要，标识列可以与其他值作比较或者通过标识列寻找其他列，也可以作为表中的外键使用。小技巧：使用整数类型可以自增；enum和set类型用来存固定信息，比如性别，类别等 。尽可能避免使用字符换类型作为标识列等。

1.7特殊类型如低于秒级的时间戳。

#### 2.一些设计陷阱

2.1太多的列：由于行缓冲之后再解码成各个列

太多的关联：如果希望插叙执行地快速并且并发性好，单个查询最好在12个表以内做关联。

过度使用枚举或者变相的枚举

#### 3.范式和反范式

3.1范式化的数据库：每个事实数据只会出现一次，反范式化的数据库信息是冗余的，可存储在多个地方。

3.2范式：

优点：更新更快+修改较少+表更小操作更快+更少的使用group场景。

缺点：通常需要关联

3.3反范式：

优点：很好地避免关联

缺点：扫描到无用的信息，导致效率低下。

3.4一般是范式和反范式混用

#### 4.缓存表和汇总表

缓存表存储每次从其他表获取但是速度比较慢的数据的表；汇总表是保存使用group by语句聚合数据的表。

4.1物化视图预先计算并存在磁盘上的表。

4.2计数器表。

#### 5.加快ALTER TABLE操作的速度

5.1用于在已有的表中添加修改或者删除列。

5.2只修改frm文件+快速创建myISAM索引等。

### 五、创建高性能的索引

#### 1.索引

也叫做键，是存储引擎用于快速找到记录的一种数据结构，索引非常关键。

1.1索引类型：

B树索引：实际上很多存储引擎使用的是B+树；它意味着每一个叶子页到根的距离相同。能够加快访问数据的速度原因是不再需要全表扫描，而是从根节点开始搜索；

哈希索引：基于哈希表实现，只有精确匹配索引所有列的查询才有效。缺点：无法排序；

空间数据索引R-tree/全文索引等其他索引。

1.2索引的优点：

`减少服务器扫描的数据量+避免排序和临时表+将随机IO变为顺序IO`

#### 2.高性能索引策略

2.1独立的列：不要在条件里把索引复杂化；

2.2前缀索引和索引选择性：如果索引很长的字符串，会让索引大且慢。此时可以索引开始的部分字符，大大节约索引空间，从而提高索引效率。这样也会使得它不再是唯一索引，大大降低索引的选择性：不重复的索引值（基数）/数据记录总数的比值。

2.3多列索引：这并不是为每个列创建单独的索引，或者按照错误的顺序创建多列索引。MySql中引入“索引合并”一定程度上可以使用多个单列索引来定位指定的行。这种算法包括：

OR条件的联合UNION

AND条件的相交INTERSECTION

以及上述两种情况的组合。

索引合并有是有是一种优化的结果，但是实际上更说明了表上索引的糟糕：

> 当对多个单列索引做相交时就要考虑构建多列索引；

2.4合适的索引顺序：将选择性高的索引放在索引的最前列，不过这条经验非常依赖选定的具体值。

2.5聚簇索引：不是一种单独的索引结构，而是一种数据存储方式，它依赖于不同的实现方式，InnoDB实际上是在同一个结构中保存了B树索引和数据行。找到索引就找到了数据。

优点：可以把相关的数据保存在一起+访问数据更快

缺点：聚簇能提高IO性能，如果数据在内存中，那么聚簇索引的优势就没了+插入速度严重依赖插入顺序（因为不是主键索引）+更新聚簇索引的代价很高+插入新行的时候可能面临页分裂+导致全表扫描变慢等。

2.6覆盖索引：一个索引包含或者说覆盖所有需要查询的字段的值，称之为覆盖索引。

优点：减少数据量访问（只需要读取索引即可）

2.7使用索引扫描做排序：Mysql有两种方法生成有序的结果：排序操作或者按索引排序来扫描数据。扫描索引本身是很快的，因为它本身就是一个数据结构，只需要从一条索引记录移动到紧接着的下一条记录。（只有索引的列顺序与order-by子句的顺序完全一致时才能使用索引对结果排序。）

2.8前缀压缩索引：通过压缩可以让更多的索引放到内存中；相同前缀字符串时只保存这个前缀，然后只需要存后缀即可。

2.9冗余和重复索引、未使用的索引都可以考虑优化。

2.10索引和锁：索引可以让查询锁定更少的行，如果更多的行上锁：额外开销+增加锁争减少并发；

#### 3、优化排序

3.1如果一个用户要搜索到的第10000页，反范式化、预先计算、缓存是可能解决这类查询的仅有策略；一个更好的办法是限制用户能够翻页的数量。另外一个策略是使用延迟关联：通过使用覆盖索引查询返回需要的主键，然后再根据这些主键关联表获得需要的行。

#### 4、维护索引和表

4.1维护表的目的：找到并修复损坏的表+维护准确的索引统计信息+减少碎片；

4.2如果损坏的是索引，可以将数据导出一份，然后再重新导入；如果损坏的系统区域，可以从备份中恢复表，或者从损坏的数据文件中尽可能地恢复数据。

4.3减少索引和数据的碎片：数据碎片有：行碎片+行间碎片+剩余空间碎片；

### 六、查询性能优化

#### 1.慢查询

1.1大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化：查询了不必要的记录、多表关联时返回全部列、总是取出全部列等。





























































































































































































