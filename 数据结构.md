**数据结构的使用**

**1.哈希表**

初始化：

unordered_set<int>hashtable(vector.begin(),vector.end());

unordered_map在初始化的时候就可以考虑做find操作来使用其他的算法，这样还可以节省后续算法的复杂度。

**2.优先队列**

使用的时候语法要求：

priority_queue<int,vector<int>,less<int>()>；默认是less<int>()

对于sort，同样默认是less<int>();

| 队列类型       | 共有的函数    | 独有的函数                             |
| :------------- | ------------- | -------------------------------------- |
| queue          | top/push/pop/ | /                                      |
| deque          | emplace/swap  | iterator/erase/clear/assign/front/back |
| priority_queue | size/empty    | /                                      |

优先队列其实就是一个堆，堆就是一个完全二叉树，能同时保证父子结点的顺序关系。

**3.二叉树**

a.二叉搜索树是个有序树，平衡二叉搜索树AVL。

b.C++中map set multimap multiset 的底层实现都是平衡二叉搜索树，

c.unordered_set unordered_map 底层实现是哈希表。

d.二叉树可以用链式或者数组两种方式储存。

e.二叉树主要有两种遍历方式，分别是深度优先搜索dfs和广度优先搜索bfs

前者分为前中后序遍历，后者就是层序遍历。

dfs是可以借助栈来实现非递归的实现方式的，而bfs要借助队列。

g.骚操作：auto [v, l, r, n] = *Node;

【117】比较高级

【110】这题能够用作二叉树递归过程中碰到异常值如何处理的例子。

【513】的dfs实现？

【113】传值与传引用的不同。传引用居然可以实现

[二叉树层次遍历的dfs实现]

```
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        dfs(res, root, 0);
        return res;
    }
    void dfs(vector<vector<int>>& res, TreeNode* root, int level) {
        if (!root) return;
        if (level >= res.size())
            res.push_back(vector<int>());
        res[level].push_back(root->val);
        dfs(res, root->left, level + 1);
        dfs(res, root->right, level + 1);
    }
};
```

【公众号】https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/面向大象编程

https://blog.csdn.net/fuxuemingzhu/article/details/101900729



### 红黑树

1. 二叉搜索树BST AVL 红黑树 B树

   平衡二叉搜索树AVL，234树，一个2-3-4树对应多个红黑树；（由来和意义？）2-3-4树是一个满树，有多少个子结点就叫这个节点是几节点。

2. 一个红黑树只能对应一个234树，但是一个234树可以对应多个红黑树。

3. 第四个结点要进来时，原来的四结点中间的节点会**上弹**。

4. 红黑树中2 -3-4节点都是上面黑，下面红。红黑树新增都是以红色的身份插入进来。在裂变状态的前一个状态时，被插入位置是一个4节点，此时中间节点是黑色的，而一旦插入了另外一个，那么它会变成红的上弹出去，而其他两个会是黑色的。如果上弹的元素变成了根节点，那么还是会变黑。

5. 子结点在左边就是左倾，子节点在右边就是右倾。红黑树上任何一个黑色节点的数目都是相同的。

6. **红黑树五大性质**

   >   节点带色+根是黑色+叶子黑色+红色必有两个黑子+黑色平衡

7. 空节点是黑色的。2-3-4树每个节点都会有一个黑色的。

8. 二叉树中如果要删除节点，要找到前驱和后继节点。这与找最值是分不开的。最后不要真的以为是删除某个节点，可以把它统一到替换值上面来。

9. **寻找前驱节点**：如果存在左子树，那么必定在左子树的右枝；如果不存在左子树，那么其前驱节点必定在尖顶的左父亲（第一个左拐的地方）。

10. 红黑树节点的删除：



### vector攻略

1.不同的编译器vector有不同的扩容大小，VS=1.5倍；GCC=2倍。2倍的时候有个问题就是不能复用前面已经用过的空间。

2.vector的capacity在使用后无法变化，如果要释放这块内存可以借助临时对象：

`vector<int>().swap(myUsedVectorName)`

3.std::erase()，以及vec.erase(iter);



### map攻略

1.unordered_map中的底层构造是哈希表。

2.map的插入方式：

> ```C++
> table.insert({1,2});
> table[6] = 7;
> table.insert(std::pair<int ,int>(2,3));
> table.insert(make_pair(4,5));
> table.insert(map<int ,int>::value_type(8,9));	
> ```

3.如果用一个map中不存在的key进行查找，会默认插入0；

### unordered_map/unordered_set攻略

1.扩容时间：当哈希表中已经容纳的元素个数=哈希表桶的个数*负载因子

### list攻略

1.splice(位置-iterator，内容one-list，区间range-iterator);

2.std::advance(iterator,steps);





