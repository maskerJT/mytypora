## 知识点个人汇总

- static的作用？

  隐藏、生存期、默认0初始化、在类中的使用。
  
- this指针理解？指针为何不是引用？

  实际上是成员函数的形参、=的重载、本身做实参、静态多态。

  https://www.zhihu.com/question/280813297/answer/417360080

- 静态多态？

  虚函数称为动态多态，奇异递归模板模式CRTP（curiously recurring template pattern）(modern c++ design 2001 安德烈)称静态多态，该模式广泛应用在boost库、windows的ATL和WTL库。

  CRTP中，基类模板中的函数可以通过使用this指针，调用到派生类中的新函数。使用效果相当于在编译时模拟了虚函数调用（能访问派生类中的成员）但是避免了虚函数的尺寸和调用开销，缺点是不能在运行时做出动态绑定。

  `原理：利用了基类模板中的函数在声明以后不会被立刻实例化，只有被调用的模板类成员函数才会被实例化`

- const关键字？

  修饰变量，指针，类的成员变量和成员函数，函数返回值等。

  const类对象，只能调用类中的后const成员函数；类中的后const函数不能修改任何成员变量，也不能调用其他任何非const成员函数。mutable

- 形参与实参？

  实参可以是常量、变量 、表达式、函数，必须有确定的值。

  形参是实参在某个函数中对实参的临时拷贝。

- 类与类之间的关系

  依赖、关联（聚合、组合）、继承、实现。

  > - 继承：也称泛化。
  > - 实现：虚函数
  > - 其他四种为语义级别的，比较难理解。

- 指针传递本质上是值传递：

  是实参指针的替身。

- C++中的默认初始化：位于函数体之外的任何变量初始化为0，而函数体内部的变量将不被初始化。

- 如果派生类中的虚函数没有被override将直接继承在基类中的版本；在类定义时类名后加入final关键字将无法作为基类。间接继承的列表初始化。

- 受保护成员对类内行为像public，对类外行为像private。派生类B中的成员函数或者友元函数只能通过派生类B的对象来访问基类的受保护成员。

- 从汇编层来看，引用的确是通过指针来实现的。

- new/delete与malloc/free的区别？

  new[]时专门使用了4字节来保存数组的大小，delete[]因此可以知道需要调用析构函数多少次。两组内容不能混用。

- malloc/realloc/calloc第三种用于扩充动态空间扩容。

- emplace_back相比于push_back：内存优化：就地构造，不在拷贝一个复制品+强制类型转换实现；运行效率方面省去了拷贝构造函数。

- 与声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化。int &&a=10;

- 完美转发：函数模板可以将自己的参数完美地转发给内部的其他函数，而且保持参数的左右属性不变。

  > 为什么需要完美转发？因为这将决定参数传递过程中使用的是拷贝语义还是移动语义（调用拷贝和移动构造函数）。
  >
  > C++11之前实现完美转发的方式有但是比较笨拙：通过非const左值引用来实现左值的接收，而通过const左值引用既可以接收左值也可以接收右值的特点来实现对右值的接收，因此只需要定义两个函数，根据const的有无来接收左右值。
  >
  > C++11 标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。但对于函数模板中使用右值引用语法定义的参数来说，它不再遵守这一规定，既可以接收右值，也可以接收左值（此时的右值引用又被称为“万能引用”）。即右值引用是万能引用。
  >
  > 模板函数（使用万能引用），函数的底层会变成A(&& &&)和A(&& &)，C++11引入引号折叠规则。
  >
  > **此时左右值的接收问题搞定**
  >
  > 无论传入的形参是左值还是右值，对于函数模板内部来说，形参既有名称又能寻址，因此它都是左值。
  >
  > forward<T>() 函数模板用于修饰被调用函数中需要维持参数左、右值属性的参数。

  

  

