## 一、输入网址

1. HTTP协议【应用层】

   > **URL解析**
   >
   > **生成HTTP请求报文**(请求行+消息头+消息体)
   >
   > **收到响应报文**（状态行+消息头+消息体）

2. DNS协议 ：【域名解析获取IP】【UDP-port:53】

3. NAT协议：【为私网主机执行端口转换达到辨识度】

4. TCP协议：【传输层-数据段】

5. IP 协议：【网络层-数据包】

6. ARP协议：【网络层-获取Mac地址】

7. MAC协议：【链路层-数据帧】

8. 网卡驱动：信号转换

9. 交换机【工作在Mac层，属于二层网络设备】

10. 路由器【工作在IP层， 属于三层网络设备】

11. RIP协议：【更新路由表】【UDP，无固定端口号】

注意：ARP在OSI中属于链路层，在TCP/IP中属于网络层；路由器的各个端口都有MAC地址和IP地址；端口号运行于传输层，四元组用来标识计算机中不同的进程。



## 二、TCP攻略

1. TCP头部格式：

   > **源端口号+目的端口号+序列号+确认应答号+首部长度+标志位+窗口大小+校验和+数据**

2. 标志位有6个：

   > **URG+ACK+PSH+RST+SYN+FIN**

3. 与UDP之间的区别

   > **连对可开数控**： 连接+对象+可靠+流量控制+开销+数据流
   >
   > **UDP的优势：**网络状况好的情况下，可靠性可以通过应用层保证
   >
   > ​						TCP的复杂度导致难以改进
   >
   > ​						TCP一旦丢包会重传无法保证实时性。

4. 三次握手

   > **SYN报文(SYN+客户端序列号)**
   >
   > **SYN/ACK报文(SYN+ACK+服务端序列号+确认号)**
   >
   > **ACK报文(ACK+确认号)**，此时可以携带数据
   >
   > 
   >
   > 为什么要三次握手？
   >
   > **避免历史连接**:网络拥堵的情况下，客户端发送了多个SYN，如果是收到历史SYN的ACK，第三次握手会返回RST表示终止这一次连接。
   >
   > **同步双方初始序列号**：（四次握手的简化版）两次握手只能保证客户端的序列号被接收；
   >
   > 避免资源浪费：当客户端在网络拥堵的情况下发送多了SYN时，两次握手会导致开启多个无用的TCP连接 。

   > （1）如果第一次握手中SYN没有收到回应，会超时重传SYN，每次的RTO（retransmission time out）时间翻倍，重传一定次数后终止。
   >
   > （2）如果第二次握手中没有收到SYN+ACK，两边都会超时重传；如果此时客户端继续发送SYN，就会重置服务端的超时定时器以及重传次数。
   >
   > （3）如果第三次握手服务端没有收到ACK，服务器会重传SYN+ACK，达到一定次数后断开连接，而此时客户端连接依然存在；这时如果客户端再给服务端发送数据将得不到回应，超时重传15次后，主动断开。（保活计时器在起作用。）

   > FASTOPEN：TCP快速建立连接：完整的一次需要2.5个RTT(round trip time)，可以在第三次握手中携带数据，就降为2RTT。

   TCP有累计确认机制，当收到多个数据包以后，只需要应答最后一个数据包的ACK报文。

5. 既然IP层可以分片，为什么TCP层还要设置一个MSS来分片呢？

     	如果某个TCP报文没有分片，而是由IP层分片，那么一旦某个IP分片丢失，会导致这个TCP其他分片（因为只有第一个分片中有TCP头部）被重传。也就是说会牵连无辜。所以先双方协商MSS，这个值一般小于MTU，这个时候就不用IP层来分片了。
     	MSS在三次握手时协商，不包含TCP头和option，所以最大为1500-20(TCP header)-20(IP header)=1460.
     	顶层MSS分段好了，可以避免底层分片。但是底层分片将不再具有TCP/UDP/ICMP头部。
     	IP分片到了目的端后由目的端ip层重新组装，对上层TCP和UDP透明。
     	IP包头中有 不允许分片标志+分片标志+分片偏移标志。

6. SYN攻击？

   服务器的SYN队列和accept队列占满的情况。客户端过慢=accept被占满；SYN攻击=SYN队列被占满。

7. TCP四次挥手？

   **由于服务端的ACK和FIN一般是分开发送的，因此需要四次挥手过程。**

   > @客户端发送FIN报文，并进入FIN_WAIT_1状态
   >
   > #服务端发送ACK报文，并进入CLOSED_WAIT状态
   >
   > @客户端收到ACK，并进入FIN_WAIT_2状态
   >
   > #服务端发送FIN，并进入LAST_ACK状态
   >
   > @客户端发送ACK，并进入TIME_WAIT状态
   >
   > #服务端进入CLOSED状态
   >
   > @客户端经过2MSL之后，自动进入CLOSED状态

8. 客户端等待2MSL？（MSL=max segment lifetime）

   **主动发起连接关闭的一方才会有2MSL时间的等待。**

   （1）客户端最后一次发送ACK时，可能服务端没有接收到，此时如果贸然关闭连接，服务器会重发FIN从而在一直等待。如果在此期间内客户端又收到了FIN说明服务端没有收到ACK，2MSL将重新计时。（跟RTO有关）

   （2）确保老的分组在网络中消逝，防止对新连接产生影响

9. TCP中的计时器？

   （1）建立连接计时器（2）重传计时器（3）延迟应答计时器（4）坚持计时器（5）保活计时器

   （6）（FIN_WAIT_2）计时器（7）TIME_WAIT计时器

10. ### TCP的四大法宝：重传机制+滑动窗口+流量控制+拥塞控制：

    > **常见的四种重传机制：**
    >
    > （1）超时重传：RTO应当略大于RTT；
    >
    > （2）快速重传：发送端连续收到三个重复的ACK2后就重传，但是问题是不知道要重传哪一个。
    >
    > （3）SACK方法：(selective ack)在TCP头部选项中将已经缓存情况发送给发送方，就可以只重传丢失部分。
    >
    > （4）duplicate SACK方法

    > **滑动窗口：**
    >
    > 角度：原因+大小+组成

    > **流量控制：**
    >
    > （1）接收端根据剩余窗口的大小，设置可用窗口的大小。
    >
    > （2）如果服务端自行缩减了缓存大小，会出现丢包的现象，为了阻止这种现象发生，TCP规定必须要先收缩窗口才能减少缓存。
    >
    > （3）窗口为0时候的死锁，持续定时器；超时后进行窗口探测；有的可能在探测三次之后RST连接。
    >
    > （4）糊涂窗口综合征：通告小窗口+发送小数据；解决方式：阻止小窗口min(1/2缓存空间，MSS)作为窗口阈值；阻止小数据：nagle算法（对方窗口>MSS||缓存数据>MSS||已经收到ACK）

    > **拥塞控制：**
    >
    > （1）发送方维护的一个反映网络拥塞程度的状态变量；
    >
    > （2）没有在规定时间内收到ACK(超时重传)，就会认为网络发生了拥塞；
    >
    > （3）算法：（congestion window=cwnd拥塞窗口数）
    >
    > ​			慢启动：每收到一个ACK，拥塞窗口就会+1（指数增长）直到达到**慢启动门限**，再改拥塞避免算法；
    >
    > ​							或者说每经过一个传输轮次，拥塞窗口加倍。
    >
    > ​			拥塞避免：每收到一个ACK，拥塞窗口增加1/total(线性增长)直到发生丢包，再启动拥塞发生算法；
    >
    > ​							或者说每经过一个传输轮次，拥塞窗口+1；
    >
    > ​			拥塞发生：a、如发生超时重传时，慢启动门限降为cwnd/2，并令total=1；
    >
    > ​								b、如发生快速重传时，令total和慢启动门限都为cwnd/2；并立马进入c:
    >
    > ​								c、快速恢复算法：令cwnd=腰斩后的拥塞窗口+3，然后在进入拥塞避免状态。

11. TCP半连接队列和全连接队列

    三次握手的时候，在linux内核中维护的两个队列；超过队列限制会直接丢弃或者返回RST；



## 三、IP攻略

1. 分类地址：

   > A:/24     B:/16     C:/8     D:/28（组播）    E:/27（留备）
   >
   > 每个分类中有两个特殊IP，全0表示指定某个网络号，全1表示该网络下的所有主机用于广播。可以通过判0的位置来确定IP的分类。
   >
   > CIDR:无类别域间路由。

2. IPV4:32位  IPV6:128位

3. IP协议相关的协议：

   > DNS/ARP/RARP/DHCP/NAT/ICMP/IGMP
   >
   > - DNS:URL解析流程=浏览器缓存+操作系统缓存+hosts+DNS服务器；本地DNS服务器->根DNS服务器->下层DNS
   > - RAP：已知IP获取MAC地址；
   > - RARP：已知Mac地址求IP地址。
   > - DHCP：局域网动态获取IP地址，底层通过UDP通信。
   > - NAT：私有地址转为公有地址。NAT穿透是指内部主机上的应用程序主动调整自己的端口映射条目，从而对外通信。
   > - ICMP：互联网控制报文协议：PING（ICMP类型有目标不可达、重定向、超时）
   > - IGMP：加入和退出组播。

4. PING的生前死后

   > > **分为查询报文类型和差错报文类型**
   > >
   > > 查询报文类型：8-回送请求；0-回送响应。（ping，命令的使用）
   > >
   > > 差错报文类型：3-目标不可达；4-原点抑制（网络拥堵的时候主机你不要添乱）；
   > >
   > > ​							5-重定向消息(路由器有更好的路由信息)
   > >
   > > ​                            11-超时信息：IP包中有个TTL生存周期字段，每经过一个路由器减1，为0时丢弃，返回超时
   >
   > > **tarcert命令的作用：**
   > >
   > > ​		发送不同TTL的UDP数据包，路由器每次返回一个ICMP错误代码，就可以**获取沿途的所有路由器IP地址**，并故意发送一个不可能的端口(>3000)目的主机会返回3-，来表示抵达了目的端。
   > >
   > > ​		利用分片禁止标志位，来使得路由器丢弃要发送的数据包，随后收到不可达3-和链路MTU。即每次收到ICMP差错报文就减少MTU即可。

## 四、HTTP攻略

1. HTTP协议报文

   > **请求报文**(请求行+消息头+消息体)
   >
   > **响应报文**（状态行+消息头+消息体）

2. HTTP请求方法：

   > **GET+POST+PUT+TRACE+DELETE...**

3. HTTP状态码：

   > **1xx:**中间态，事务还没处理完
   >
   > **2xx:**成功
   >
   > **3xx:**重定向，需要客户端重新发送请求
   >
   > **4xx:**客户端错误，请求报文有误
   >
   > **5xx:**服务器端内部错误

4. HTTP演进：

   > **HTTP1.0**
   >
   > - 优点：简单灵活、易于拓展、应用广泛、跨平台。
   > - 缺点：无状态（服务器产生cookie后每次双方都要带上）、明文、不安全（可能会被窃听、伪装、篡改）。
   >
   > **HTTP1.1：**
   >
   > - 长连接：只要任意一端没有提出断开，保持TCP连接状态。
   > - 管道传输：允许客户端同时发出多个请求。
   >
   > - 队头阻塞：顺序发送的多个请求中某一个阻塞时，后面的也一同被阻塞。
   >
   > **HTTPS：**
   >
   > - SSL/TLS握手：HTTPS在TCP三次握手之后，还要进行SSL/TLS的握手，从而进入密文传输，HTTP端口号是80，HTTPS端口号是443。
   > - 混合加密：对称加密与非对称加密结合起来，快与安全间的平衡。建立通信前采用非对称交换会话密钥，通信过程中采用对称加密明文数据。
   > - 摘要算法：生成数据指纹，并与明文一同发送，避免篡改。
   > - 数字证书：服务器公钥发给别人，收到的密文用自己的私钥解密。
   >
   > **HTTP2.0**
   >
   > - 头部压缩：HPACK算法，两端同时维护一个头信息表用以存储字段并生成索引号，多个请求头一样时，就可以只发送索引号。
   >
   > - 二进制格式：头信息和数据都是二进制，不再采用纯文本的形式。
   >
   > - 数据流：HTTP2中长连接数据包不是按照请求-响应的顺序发送的， 因此数据包必须标记其所属的数据流ID。每个请求或者回应的所有数据包称为一个数据流。两端可以发送信号（RST_STREAM帧）来取消这个数据流，而HTTP1中只能关闭TCP连接。
   >
   > - 多路复用：可以在一个连接中并发多个请求或者回应，所以不需要串行就不会存在队头阻塞。
   >
   > - 服务器推送：客户端在请求HTML时，服务器提前把各种静态资源主动发送给客户端，减少等待的时延。
   >
   >   【缺点】：多个请求复用一个tcp连接，一旦丢包，所有请求都必须等待这个丢了包重传回来才能继续。
   >
   > **HTTP3.0**
   >
   > - 把下层的TCP协议改成了UDP，使用QUIC协议可以实现类似TCP的可靠性传输。
   >
   > 

附录：安全的-指请求方法不会破坏服务器上的资源；幂等-执行多次结果都是相同的。



## 五、cookie、session、token

1. cookie是服务器生成的，然后发送给客户端，当客户端下一次请求时会把自己的cookie发给服务器，从而达到识别身份的目的。

2. session指会话，服务器使用session把用户的信息起来，用户离开以后销毁session。但是有个缺陷是当服务器做了负载均衡时，下一个操作请求到了另一个服务器时session会丢失。

3. token：服务器不再保存session id，而是生成token，然后使用自己的密钥验证session。使用计算时间换取了服务器的session存储空间。

4. cookie和session的区别：

   > - 存储位置不同，cookie在客户端，session在服务器。
   > - 存储容量不同，cookie一般不超过4KB，session无限制。
   > - 隐私策略不同，cookie可见。
   > - 对服务器的压力不同。

5. token的优点

   无状态、可拓展、支持多种设备、安全。

## socket攻略

1. 监听和真正传输的是两个socket
2. 客户端connect成功是在第二次握手；服务端accept成功之后是在第三次握手

